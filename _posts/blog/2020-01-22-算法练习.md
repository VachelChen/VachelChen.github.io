---
layout: post
title: 算法练习
categories: 算法
description: 身为一个程序员可以说数据结构以及算法知识是基本功了，此次为了本科期间最后一次征战蓝桥杯能去得理想的成绩，我决定全力以赴，争取拿到一个国家级的名次。
keywords: 数据结构,蓝桥杯，ACM
---

数据结构和算法是程序员的基本功，也是各大学校各大厂十分看重的敲门砖，本人参与过一些竞赛，竞赛除了考察对数据结构的掌握其实还存在许多的套路，这里进行一个总结与归纳，希望可以在日后参加竞赛时去得更好的成绩。

## 常见问题知识储备

**指针基础**  

指针：  

```c
//获取变量的地址 &
int a = 1;
printf("%d\n", &a);

//指针变量用来存放指针（或者可以理解为地址）
int *p;
int* p; //两种情况等价
//要明确的是，定义完指针变量后，指针变量是 p，而不是 *p

//因为 & 可以得到变量的地址，所以给指针的赋值就变成了：
int a;
int *p = & a;
//所以地址 &a 是赋值给了 p 而不是 *p

//得到地址里的东西，还是使用 * ，把 * 当作是开启房间门的钥匙
int a = 233;
int* p = &a;
printf("%d\n", *p);
//output：233 

```

指针与数组：  

```c
//数组的名称也具有收地址的作用
int a[10];
a == &a[0];

//指针变量的加减法在数组中最为常用
a + i == &a[i];

//输入 与 输出
int a[10];
for(int i=0;i<10;i++)
  scanf("%d",a+i);    //之前用 & 原来是表示地址，现在已经是存储的地址了所以不用&

for(int i =0;i<10;i++)
  printf("%d\n", *(a+i)); //输出值


```


**C语言数组放在main函数里面和外面的区别**  

几个概念：    

栈区：由操作系统自动分配释放，存放函数的参数值，局部变量的值；当不需要时系统会自动清除。  

堆区：由new分配的内存块，不由编译器管，由应用程序控制（相当于程序员控制）。如果程序员没有释放掉，程序结束后，操作系统会自动回收。  

数据区：也称全局区或者静态区，存放全局的东西类似全局变量。  

代码区：存放执行代码的地方，类似if else，while，for这种语句。  

在main函数里面的数组是开在栈区(stack)，在函数外面的是开在数据区的。栈区的内存比较小，所以当数组非常大的时候，就会报错。假如把数组放在数据区就不会出现这个问题，因为数据区的内存很大。

```c
#include <iostream>
using namespace std;

//main函数外为数据区，差不多是真实计算的内存大小
long long a[20190325];


int main(int argc, const char * argv[]) {
    // insert code here...
    //main函数内 为栈区 内存块比较小
    a[1]=1;
    a[2]=1;
    a[3]=1;
    for(long long i=4;i<=20190325;i++){
        a[i]=(a[i-1]+a[i-2]+a[i-3])%10000;
    }
    cout<<a[20190324]<<endl;
    return 0;
}
```



**时间复杂度处略估计**  
首先估计O(n)，例如时间复杂度为O(n),n的规模为1000，那运算就是10^3.  
O(n^2),规模为1000，那运算就是10^6.  

*对于一般的OJ来说，1s所能承受的运算次数是10^7~10^8*  




**C++题目开数组下标确定**  
绝大部分题目会给出数组的上限指标，但是当数组界限未给定时要自行运算一下，就比如2013年蓝桥省赛中大臣的旅费一题，其中没有给定要输入的n（表示城市数）的规模，我在自己的Xcode上演算无误后提交却一直出现运行错误的问题。  

查阅资料后发现蓝桥杯最大栈空间为256MB，于是我进行了如下演算：  

![shuzu](/images/blog/shuzu.png)  

得出如下结论：*最大可以开1乘10的7次方左右的数组空间*  

```c
	//合理开辟方法例子如下：
	int a[10000000]; //二维数组最大合理大小

	int a[1000][1000]; //二维数组最大合理大小
```



**int形最大存储位数**  
int为4字节，也就是共32位存储，可以存储负数说明第一位用来存储符号，所以其表示范围为：  
```c
	-2^31~2^31
	2^31 = 2 147 483 648 (10位数)
```
ps : 值得注意的是，当两个int进行类似乘或者平方等位数增长类运算时，若突破10位后再用long long接收是接收不到正确的数字的，只能接收益处的数字，*所以当面临溢出风险时最好在运算前直接设为long long型*  

这里给出所有数据类型：  
![shuzu](/images/blog/foundationDatatype.png)  




**Excel日期计算**  
Excel可以帮助我们对日期直接进行加减天数的计算，但是只识别1900-1-1日之后的日期。



**位运算**  

想成为高级程序员躲不开位运算。  
```c++
	+ - 	需要 2  个CPU时钟
	位预算	需要 1  个CPU时钟
	*		  需要 4  个CPU时钟
	/		  需要 40 个CPU时钟
```

位运算会将数据显变换成二进制再进行演算：  

![weiyunsuan](/images/blog/weiyunsuan.png)


**闰年判断**  
闰年的判断其实有两个条件：  
1.年份能被4整除但是不能被100整除,例如4  
2.年份能被400整除，例如400  
ps：之前混淆，其实这两个条件并不冲突，这两个条件不是要求同时满足，是满足一个即是闰年。  



## 常见字符串处理  


**string中的.erase与.substr方法**  
之前大概都知道.erase是用来消除元素的，.substr是用来截取子串的，但是今天用的时候发现不太会用，特此注明一下，至于为什么把这两个函数写在一起，是因为他们的用法相似。函数都有两个参数要传。  

分别是：position(pos), length(len)  

表示：要处理的位置（从0开始），处理的长度   

```c++

string str = "0123456";

string sub = str.sub(2,2);
// output:23

str.erase(3,1);
// output:012456

//总结也发现sub一般采用接收返回值的方法，erase通常不适用接受值直接对原字符串进行改变。  

```


**string中的.find方法详解**  
用来寻找一个字符串中是否含有子串或子字符，常使用如下：  
```c++
//默认从左开始找
母串.find(子串或子字符)！=string::npos  

//从右开始找
母串.rfind(字串或字符串)！=string::npos  
```
其中 string::npos 表示没有找到。  



**数字字符(int)对字符(char)的相互转换**  
由于int+或-char类型可以直接转换为char类型，所以常借助ascii码表数字排位第一的'0'字符来转换：  

```c++
//将1转换为'1'
	char yi = 1+'0';
//将'1'转换为1
	int yi = '1'-'0';
```



**数字字符串(int)对字符串(string)的相互转换**  
```c++
#include<sstream>

//数字转换成字符串
void i2s(int x,string &str){
	stringstream ss;
	ss << x;
	ss >> str;
}

//字符串转换成数字
void s2i(int &x,string str){
	stringstream ss;
	ss << str;
	ss >> x;
}

```



**接收不确定的输入长度回车截止**  
有时会输入不确定个数的数字，以空格隔开，以回车结束，由于c没有java那样直接对字符串分割的函数

```c++
#include<sstream>

const int Maxn = 10000;


int data[Maxn];
string s;

getline(cin,s);	//先按行接收 若是之前有输入记得用 getchar()接收回车
istringstream iss(s);

string temp;

//getline 其实自带分割
//但是第一个参数需要使用istringstream
//第三个参数确定分割依据
//第二个参数确定存入哪里

while(getline(iss,temp,' ')){	
	//进行存储
	s2i(tmp,data[index++]);
}
```

**C语言中接受参数忽略及动态输出**  


```c

int a;
char b[10];
scanf("%d %*s",&a,b);   //a会被接收 b不会

printf("%*s",10,s);     //输出字符串s，不足的地方用s补空格

```

**stl模版中的去重函数unique**  

没想到stl里面还有这种好东西，他可以删除序列中相邻的重复元素，所以一般在使用前需要用sort进行排序。  


```c
//完成排序后；

unique(a, a+n);//  只能把相邻的数字中的多余部分放到数组后；

//要达到去重的目的还需要：

n = unique(a, a+n) - a;

```


---

## 数学知识点

**找1～n素数**  

*普通暴力求解*  


```c
#include <cmath>

for(int i=2;i<=n;i++){
	bool judge = true;
	for(int j=2;j<=sqrt(i);j++){
		if(i%j==0){
			judge = false;
		}
	}
	if(judge)
		sushu[index++]=i;
}


```  


**素数筛法**  

思路：对于任意一个合数一定可以分解成多个素数的乘积。  

做法：既然每个合数必然能分解成多个素数的乘积，那么在搜索到一个素数的时候我们就把它的倍数标记为合数。  


```c

for(int i=2;i<=n;i++){
	if(p[i]==0){
		sushu[index++]=i;

		for(int j=2;j*i<=n;j++)
			p[j*i]=1;			//p中标记的都是合数  //动态规划
	}
}


```

**线性筛法**  

思路：在上一种筛法中6会被2，3晒掉两次，浪费了时间。  

做法：将每个合数表示为一个素数乘以一个正整数的形式。  

时间复杂度O(n)  

```c

for(int i=2;i<=n;i++){
	if(p[i]==0)
		sushu[index++]=i;

		for(int j=1;j<=index && i*sushu[j]<=n;j++){
			p[i*sushu[j]]=1;
			//当遇到最小的质数是i的因数时，break
			//因为他已经有最小素数组成，而我们每次都是从最小开始遍历，避免遗漏
			if(i%sushu[j]==0)	break;
		}
}


```

**二分法查找元素**  
二分法查找元素虽然早在去年就学过，但我一直不怎么常用，说是简单其实还是有一些要注意的点：  
首先要明确二分查找是对严格递增的数组进行查找，也就是说要排序且去重。  
其次要明确边界left、right的变换过程，是变换到mid的左一个或右一个，而不是和mid一个位置。  
最后要明确出口条件那就是left始终在right左边，若不满足则退出while循环。  
具体实现代码如下：  

```c++

//二分查找
    int ans = -1;
    int left = 0;
    int right = n-1;
    int mid = (left+right)/2;
    while(left <= right){
        if(v[mid] == m) {
            ans = mid;
            break;
        }
        else if(v[mid] > m){
            right = mid -1;
            mid = (left+right)/2;
        }
        else if(v[mid] < m){
            left = mid +1;
            mid = (left+right)/2;
        }
    }

```


**快速排序**  
快排属于基础的不能再基础的排序算法之一，其一般复杂度是O(nlogn)，在最坏情况时（数排列随机性低）也会是O(n^2)。快速排序算法分为两个部分：  

1.结合two points思想，完成当前数组的划分，使得选定元素左边的数都比其小，选定元素右边的数都比其大，具体代码如下：  


```c++

//二分查找
    int ans = -1;
    int left = 0;
    int right = n-1;
    int mid = (left+right)/2;
    while(left <= right){
        if(v[mid] == m) {
            ans = mid;
            break;
        }
        else if(v[mid] > m){
            right = mid -1;
            mid = (left+right)/2;
        }
        else if(v[mid] < m){
            left = mid +1;
            mid = (left+right)/2;
        }
    }

```



**快速幂用于求a^b**  

时间复杂度O(logb)  

```c

//初始化为1，意义在于乘以它不改变，有点像离散数学中的单位元
int ans=1;
// 把指数拆成二进制
while(b!=0){
	//幂不为零

	if(b & 1)	{    
    //如果 指数位的结果是1 那我就要 把它乘以结果
    ans=ans*a;  
  }
	a=a * a;//每次右移结果都要翻倍 就是平方

	b>>=1; //进行右移
}

```
明人不说暗话，我理解起来还是比较困难的....  
20.2.19，我终于理解了，个人感觉网上的二分法不是很好理解，还是理解成二进制运算好。  



**辗转相除法（欧几里德算法）求最大公约数（gcd）**  

求最大公约数的简洁代码如下，有了最大公约数也可以求最小公倍数。  

```c++

//最大公约数
int gcd(int a,int b){
	return a%b==0?b:gcd(b,a%b);		//辗转相除法中没有除法，均做余运算
}

//最小公倍数

int x = a*b/gcd(a,b);

```


**互质问题**  

两个数x,y如果互质，那么 x\*y-x-y之后的数都是可以用x、y的整数倍拼出来的，互质的含义也就是用辗转相除法得到的最大公约数是1.  
而多个数的互质可以两两来运算，先得到两个数的最大公约数，再用这个数和之后的数用辗转相除法，若最后结果是1，则表示多个数互质。  



**cmath库中的常用函数**  

cmath中有许多常用来数学计算的函数，这里做一个统一复习：  

```c++
#include <cmath>

fabs(double x); //取double型绝对值。  

floor(double x);  //向下取整  floor(5.2) = 5   floor(-5.2) = -6
ceil(double x);  //向上取整  ceil(5.2) = 6    ceil(-5.2) = -5

pow(double r, double p);  //返回r的p次方，不过现在我一般用快速幂求解了

sqrt(double x); //返回x的算术平方根

log(double x);  //返回x以e为底的对数
//若想变换成自己想要的底则需要用到换底公式 ： logab = logeb/logea 

round(double x);  //对x四舍五入取整

//圆周率的精确表示 pai = arccos(-1)
double pi = acos(-1.0)
```



**数列知识**  

```c

//等差数列：
  an = a1 + (n-1)d;
  Sn = n*(a1-an)/2

//等比数列：  
  an = a1q^(n-1);
  Sn = a1(1-q^n)/(1-q);


```


---

## 一、枚举及全排列

**数字位全排列**  
对一串指定长度为n的数字要对每一位做全排列的话，若直接使用n位最小数字到n位最大数字的一个for循环，在取出每一位上数字时会较为麻烦，这时候推荐采用n个for循环，在每一个循环中添加约束条件会比较清晰。  
```c++

//取各位都不一样的六位数

//推荐做法：
for (int i = 1; i < 10; ++i) {
        for (int j = 0; j < 10; ++j) {
            if (j != i)
                for (int k = 0; k < 10; ++k) {
                    if (k != i && k != j)
                        for (int l = 0; l < 10; ++l) {
                            if (l != i && l != j && l != k)
                                for (int m = 0; m < 10; ++m) {
                                    if (m != i && m != j && m != k && m != l)
                                        for (int n = 0; n < 10; ++n) {
                                            if (n != i && n != j && n != k && n != l && n != m) {
                                                long long x = i * 100000 + j * 10000 + k * 1000 + l * 100 + m * 10 + n;
                                                if (check(x, x * x)) {
                                                    cout << x << " " << x * x << endl;
                                                }
                                            }
                                        }
                                }
                        }
                }
        }
    }

//我的做法

for(long long i=123456;i<=987654;i++)
    {
        liu = i%10;
        wu = (i-liu)%100/10;
        si = (i-wu*10-liu)%1000/100;
        san = (i-si*100-wu*10-liu)%10000/1000;
        er = (i-san*1000-si*100-wu*10-liu)%100000/10000;
        yi = (i-er*10000-san*1000-si*100-wu*10-liu)/100000;
        if(liu==wu || liu==si || liu==san || liu==er || liu==yi || wu==si || wu==san || wu==er || wu==yi || si==san || si==er || si==yi || san==er || san==yi || er==yi)
            continue;
        //····
    }



```


**全排列**  
全排列是一个常见操作，其实一个函数就可以解决：  

```c++
#include<string>
int main(int argc, char const *argv[])
{
  string s="223344AA"    //首先给出一个字符串
  do{
    if(check(s)){        //在check函数中对字符串进行检查
        cout<<s<<endl;
    }while(next_permutation(s.begin()s.end())); //模版
  }
  return 0;
}
```



**特殊去重**  
手环排列问题，要把s+s以及s+s的反向加入vecter。  

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

vector <string> v;

int main(int argc, const char * argv[]) {
    string s = "rrrwwwwyyyyy";
    int ans=0;
    do{
        int i;
        for(i=0;i<v.size();i++){
            if(v[i].find(s)!=string::npos)  break;
        }
        if(i!=v.size()) continue;
        ans++;
        string s2=s+s;
        v.push_back(s2);
        //翻转函数的用法
        reverse(s2.begin(), s2.end());
        v.push_back(s2);
    }while(next_permutation(s.begin(),s.end()));
    cout<<ans<<endl;
    return 0;
}
```

---

## 二、大数运算

**填空题大数运算技巧**   

蓝桥中有填空题，不像ACM时全部要求提交源程序，这就可以利用其他语言来取个巧，比如 Python 和 Java都是支持大数运算的：  
Python 不一定在考试机上有，但我个人认为 Python 是最方便的,只需要最简单的idle即可完成运算：  

![pythonshiyan](/images/blog/pythonshiyan.png)

Java虽然写法复杂一些，但一般考试机上都有 eclipse ,Java一般使用 BigInteger 大数类，需要熟练掌握其方法：  

```java
//头文件
import java.math;

//大数赋值,不是快速装箱，是普通的将普通数值转换为大数值
BigInteger a = BigInteger.valueOf(2000);

//c = a+b
BigInteger c = a.add(b);

//c = a-b
BigInteger c = a.subtract(b);

//c = a*b
BigInteger c = a.multiply(b);

//c = a/b
BigInteger c = a.divide(b);

//c = a%b
BigInteger c = a.mode(b);

//判断两大数是否相等，相等返回0
if(a.compareTo(b));

```


**long long的所能容纳的长度**  
一般大数运算在加减之间比较多，设计乘除难度比较大，所以一定要很好的区分大数，我理解大数是用long long都不够装的数字：  

```c

//	long long 占8字节
//	8字节=64位 其中第一位勇于存放符号

	-2^63~2^63
	2^63 = 922 337 203 685 477 5807 （上限大约是20位十进制数）

```
简单记为：int 10位  long long 20位



---

## 三、排序  

既然都是练习了也别老想着用sort排序了，复习一下基础。  

**冒泡排序**  

```c++

#include <iostream>
using namespace std;

int main(int argc, const char * argv[]) {
    int a[10] = {3,65,13,67,96,24,22,74,34,25};
    for(int i=0;i<10-1;i++){
        for(int j=0;j<10-i-1;j++){
            if(a[j]>a[j+1]){
                int temp;
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
    for(int i=0;i<10;i++)
        cout<<a[i]<<"\t";
    return 0;
}

```





---

## 四、图论

### DFS、

**完成重复子问题的优化**  

1.记忆型递归  
这个位置+状态是已经遇到过的，进行存储，避免走重复的路。  

```c++
//设置缓存
#include<cstring>

long long cache[xMax][yMax];//也可以根据位置+状态调整为多维；

//得用返回值的形式
long long dfs(int x,int y){
    //查缓存
    if(cache[x][y] != -1) return cache[x][y];

    //为了给cache存当前节点到目标的有效值，需要在每次迭代中归零ans
    long long ans = 0;

    //dfs过程.....


    //写缓存
    cache[x][y] = ans;
}

int main(int argc, char const *argv[])
{
  memset(cache,-1,sizeof(cache));
  dfs(x,y);
  return 0;
}
```


**dfs解决类bfs问题**  

在刷蓝桥的题目的时候，已经不止一次遇到一种特殊的dfs统计，类似于：  

![dfss](/images/blog/dfss.jpg)  

若从左上角是起点，则永远无法用dfs遍历出这种形状的结果，这时有人会说为什么不使用bfs，bfs虽然能得到这种结果，但又只能得到这种结果，本身还不具有计数功能，就是十分蛋疼。  

面对这种情况，我在网上看到了一篇还不错的帖子，其方法是：全排列+dfs。  

大致思路是：  
我先把所有的cell在数组中用0，1标出来，其中1代表选中的cell，再使用next_permutation来全排列，对每一种排序结果检测其连通性，检测方法就是选中一个cell，按照1的地图来走，若能累计加和为5，则说明可以连通，这种方法还不用去重，可谓美哉。  

粘贴一个解决2016_剪格子的代码：  

> 如【图1.jpg】, 有12张连在一起的12生肖的邮票。
> 现在你要从中剪下5张来，要求必须是连着的。
> （仅仅连接一个角不算相连）
> 比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。

![youpiao1](/images/blog/youpiao1.jpg)  
![youpiao2](/images/blog/youpiao2.jpg)  
![youpiao3](/images/blog/youpiao3.jpg)  


```c++

#include <iostream>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <vector>
using namespace std;

int a[3][4];
int visit[3][4];
int num;
bool flag;
vector<string> v;

string i2s(int x){
    stringstream ss;
    string s;
    ss << x;
    ss >> s;
    return s;
}

void dfs(int x,int y){
    
    visit[x][y] = 1;
    num++;
    if(num == 5){
        flag = true;
        return ;
    }
    
    if(x<2 && !visit[x+1][y] && a[x+1][y]) dfs(x+1, y);
    if(x>0 && !visit[x-1][y] && a[x-1][y]) dfs(x-1, y);
    if(y<3 && !visit[x][y+1] && a[x][y+1]) dfs(x, y+1);
    if(y>0 && !visit[x][y-1] && a[x][y-1]) dfs(x, y-1);
    
}

int main(int argc, const char * argv[]) {
    
    int value[12]={0,0,0,0,0,0,0,1,1,1,1,1};
    int ans=0;
    
    do{
        int n=0;
        memset(visit, 0, sizeof(visit));
        
        for(int x=0;x<3;x++){
            for(int y=0;y<4;y++){
                a[x][y] = value[n++];
            }
        }
        
        bool doubleJump = false;
        
        for(int x=0;x<3;x++){
            for(int y=0;y<4;y++){
                if(a[x][y] == 1){
                    flag = false;
                    num = 0;
                    dfs(x,y);
                    doubleJump = true;
                    break;
                }
            }
            if(doubleJump)  break;
        }
        
        if(flag){
            ans++;
        }
    }while(next_permutation(value,value+12));
    
    cout<<ans<<endl;
    return 0;
}


//答案116 
//之前单用dfs做出来次啊25，bfs做到一半发现不对...
```

当然了，只有数目较小的时候才可以用全排列，比如2017_方格分割用全排列（36取18）在有限的时间根本算不出来....而是要使用下面这张减法   


**dfs解决类bfs问题的变形**  

由于17年这个题目的特殊要求，要求剪出两边的形状一样，我们考虑从中心开始的边的dfs。  

```c++
//
//  main.cpp
//  2017_方格分割
//
//  Created by VachelChen on 2020/2/26.
//  Copyright © 2020 VachelChen. All rights reserved.
//

#include <iostream>
#include <cstring>
using namespace std;

int visit[7][7];
int ans = 0;

void dfs(int x,int y){
    if(visit[x][y]) return;
    
    if(x == 0 || x == 6 || y == 0 || y == 6){
        ans++;
        return;
    }
    
    visit[x][y] = 1;        //最后一个点一般不用标记，也就是说在满足情况的下方，不然无法标记回来...
    visit[6-x][6-y] = 1;
    
    dfs(x+1, y);
    dfs(x,y+1);
    dfs(x-1,y);
    dfs(x,y-1);
    
    visit[x][y] = 0;
    visit[6-x][6-y] = 0;
}

int main(int argc, const char * argv[]) {
    memset(visit,0,sizeof(visit));
    dfs(3, 3);
    cout<<ans/4<<endl;
    return 0;
}

```



### BFS、

**stl中queue常用函数**  

想要用好bfs，用stl模版库中的现成队列再方便不过，这里总结一下队列中的函数：  

```c
#include <queue>

queue <datatype> q;

q.empty();	//判断队列是否为空

q.size();	//访问队列q的元素个数

q.push(a);	//讲一个元素a放入队列

q.front();	//返回队列的第一个元素

q.pop();	//移除队列的第一个元素
```


**找迷宫出口、包括找最短迷宫出口这都是使用BFS来干的事**  

（说实话只在课本上学过，一直没遇到过BFS实战的题目，没想到第一次见就是在赛场上，真是教训）

BFS大致框架如下：

学习数据结构时都知道BFS和队列有关，DFS和栈有关，想着自己在使用DFS时基本根本没有使用到
stcak结构，后知后觉才反应过来自己用的递归不就是栈吗？而BFS在实战时似乎就必须要使用队列，一般不会选自己去创建队列，stl模版库它不香吗？  



```c++
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=100;
bool vst[maxn][maxn]; // 访问标记

//虽然在我使用dfs的时候不喜欢用方向向量，但发现还是使用方向向量比较简洁

int dir[4][2]={0,1,0,-1,1,0,-1,0}; // 方向向量

// 在走迷宫一类问题中，放入队列的就是位置信息

struct State // BFS 队列中的状态数据结构
{
   int x,y; // 坐标位置
   int Step_Counter; // 搜索步数统计器
};
 
 
State a[maxn];
 
 
bool CheckState(State s) // 约束条件检验
{
   if(!vst[s.x][s.y] && ...) // 满足条件
     return 1;
   else // 约束条件冲突
    return 0;
}
 
 
void bfs(State st)
{
     queue <State> q; // BFS 队列,设置为结构体类型，可以在结构体中设置一下构造函数来赋值比较方便。
     State now,next; // 定义2 个状态，当前和下一个
     st.Step_Counter=0; // 计数器清零
     q.push(st); // 入队
     vst[st.x][st.y]=1; // 访问标记

     //采用while来完成对地图的遍历
     while(!q.empty())
     {
       now=q.front(); // 取队首元素进行扩展
       if(now==G) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可
       {
         ...... // 做相关处理
        return;
       }
       for(int i=0;i<4;i++)
       {
         next.x=now.x+dir[i][0]; // 按照规则生成下一个状态
         next.y=now.y+dir[i][1];
         next.Step_Counter=now.Step_Counter+1; // 计数器加1
         if(CheckState(next)) // 如果状态满足约束条件则入队
          {
          q.push(next);
          vst[next.x][next.y]=1; //访问标记
          }
       }
     q.pop(); // 队首元素出队
  }
 return;
}
 
 
int main()
{
  ......
  return 0;
}


```  


**模拟走迷宫**  

主干仍然是BFS框架，为了方便记录一般再使用一张地图（已经是第三次使用地图，第一次地图用来记录地形，第二次用来记录访问情况），而此时这里的地图用来记录：*当到这个点时，是怎么从上一个点过来的*  

而一般对于填空题来说，答案是唯一的，当有多条路径可以选择时一般题目会强调按字典序排，对于BFS第一轮找到的一定是最短路径这不用多说，但是如何保证是最短的呢？一开始我还对这个问题有所纠结，后来仔细一想发现只要我调整BFS在四个方向的遍历顺序满足字典顺序，就可以达到目标效果。  


附上2019_迷宫：  


```c

//下图给出了一个迷宫的平面图，其中标记为1 的为障碍，标记为0 的为可
//以通行的地方。
//010000
//000100
//001001
//110000
//迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这
//个它的上、下、左、右四个方向之一。
//对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，
//一共10 步。其中D、U、L、R 分别表示向下、向上、向左、向右走。
//对于下面这个更复杂的迷宫（30 行50 列），请找出一种通过迷宫的方式，
//其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。
//请注意在字典序中D<L<R<U。（如果你把以下文字复制到文本文件中，请务
//必检查复制的内容是否与文档中的一致。在试题目录下有一个文件maze.txt，
//内容与下面的文本相同）
//(每行50个数字，格式不对的话需要自己去调整)
/*
01010
00001
01111
01000
 */

#include <iostream>
#include <queue>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;

char a[31][51];
int visit[31][51]={0};
char where[31][51];
int n,m;

struct state{
    int x,y;
    state(int _x,int _y){
        x=_x;
        y=_y;
    }
};

void bfs(){
    queue<state> q;
    q.push(state(0,0));
    visit[0][0]=1;
    where[0][0]='S';
    while(!q.empty()){
        state temp = q.front();
        q.pop();
        if(temp.x == n-1 && temp.y == m-1)  break;
        if(temp.x < n-1 && !visit[temp.x+1][temp.y] && a[temp.x+1][temp.y] != '1' ) {
            visit[temp.x+1][temp.y]=1;
            q.push(state(temp.x+1,temp.y));
            where[temp.x+1][temp.y]='D';
        }
        
        if(temp.y > 0 && visit[temp.x][temp.y-1]!=1 && a[temp.x][temp.y-1]!='1') {
            visit[temp.x][temp.y-1]=1;
            q.push(state(temp.x,temp.y-1));
            where[temp.x][temp.y-1]='L';
        }
        
        if(temp.y < m-1 && visit[temp.x][temp.y+1]!=1 && a[temp.x][temp.y+1]!= '1') {
            visit[temp.x][temp.y+1]=1;
            q.push(state(temp.x,temp.y+1));
            where[temp.x][temp.y+1]='R';
        }
        
        if(temp.x > 0 && visit[temp.x-1][temp.y]!=1 && a[temp.x-1][temp.y]!='1') {
            visit[temp.x-1][temp.y]=1;
            q.push(state(temp.x-1,temp.y));
            where[temp.x-1][temp.y]='U';
        }
        
        
    }
}

int main(int argc, const char * argv[]) {
    // insert code here...
    cin>>n; cin>>m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++){
            cin>>a[i][j];
        }
    
    bfs();
    
    char ans[1000];
    int ansindex=0;
    int x=n-1,y=m-1;
    while(where[x][y]!='S'){
        ans[ansindex++]=where[x][y];
        if(where[x][y] == 'D')
            x=x-1;
        else if(where[x][y] == 'U')
            x=x+1;
        else if(where[x][y] == 'R')
            y=y-1;
        else if(where[x][y] == 'L')
            y=y+1;
    }
    for(int i=ansindex-1;i>=0;i--)
        cout<<ans[i];
    cout<<endl;
    return 0;
}

```


**状态演变问中间步骤**  

17年的跳蚱蜢我看着很懵，我一开始还想着要用dp来做，但是后来发现这个过程极其不规律，找不到递推方程，没想到又是一种bfs的题型。  
经过某一种状态的演变，到达一个目标状态，问中间经历多少步，一般都是bfs。  

说实话早应该想到的，这个和迷宫有一个类似点：都是求最少步数，但这个貌似脱离了图论我就没往那方面想，还是要学会抽象问题。   




---

## 五、树

**二叉树的一些常用性质**  

1.二叉树的第k层上最多有2^(k-1)个节点  

2.深度为k的二叉树最多有2^k-1个节点  


**完全二叉树的一些常用性质**  

1.节点i的子节点为2i和2i+1   

2.节点i的父节点为i/2  


**最小生成树**  

最小生成树是数据结构中一种常见的经典算法，可以解决很实际的问题例如：要在n个城市中建立一个通信网络，连接n个城市最小需要布置n-1条通信线路，这个时候考虑成本最低。  

克鲁斯卡尔算法：  
  按边的权值从小到大添加到图中，并保障添加的过程不会形成环，直到连接所有顶点。  

落实到代码的步骤：
 1.接收数据确定顶点个数、边数、以及每条边的权重。  
  2.对连通网中所有的边进行升序排序（此处要重写cmp方法）。  
  3.使用一个辅助数组，来表示该顶点所处的集合，一开始顶点编号为集合编号。  
  4.从小到大遍历所有路径：  
        4.1.得到路径开始点和结束点所处的集合编号，若不同则不会产生回路。  
        4.2.记录这条边作为最小生成树的组成部分。  
        4.3.结束点的集合编号全都修改为开始点的。  
  5.当边数达到 顶点数-1 的数量时，退出循环。  



---

## 六、动态规划  

我以前都觉得这个很难，我之前做过一个题叫方糖，题目意思其实和斐波那契数列差不多  
原来我之前的解法就是动态规划的思想....   

不是动态规划的做法就是：  

```c++

void f(n){
  if(n == 1 || n == 2)  return 1;
  else
    return f(n-1)+f(n-2);
}

```

动态规划的做法就是我之前所学的打表：  

```c++
int a[100];
a[1]=1; a[2]=1;

void f(n){
  for(int i=3;i<=100;i++){
      a[i] = a[i-1] + a[i-2];
  }
}

```

这是一维的，像比较经典的题例如01背包那是二维的，大致就是若有 N 件物品，每件物品重量为 W[i] , 每件物品的价值是 V[i] 。  

设f（k，w）表示：当背包容量为w，现有k件物品可以拿，所能拿到的最大价值。   

状态转移方程是：  
```c++

#include <iostream>
#include <cstring>
#include <algorithm>
#define N 5           //N-1 为物品数
#define M 9           //M-1 为背包容量
using namespace std;

int w[0,2,3,4,5];     //每件物品的重量
int v[0,3,4,5,8];     //每件物品的价值

int f[N][M];

int main(){

    memset(f,0,sizeof(f));  //初始化数组，定义了边界，有点类似于斐波那契数列定义的前两项，需要依靠此来计算

    for(int i=1;i<N;i++){         //可选择的物品数
      for(int j=1;j<M;j++){       //剩余容量

          if(w[i]>j)    //如果物品重量大于空间容量(装不下)
            f[i][j] = f[i-1][j];  //此时情况就是上一个物品且有同样容量的情况
          else          //当我装的下时，考虑的就是拿与不拿的问题
            f[i][j] = max(f[i-1][j],f[i-1][j-w[i]]+v[i]);

      }
    }
    return 0;
}

```


**两个串的最长公共子序列（LCS）**  

之前的动态规划问题都是比较明显的，这里遇到一个十分经典但是第一次做一脸懵的DP题目，那就是求两个串的最长公共子序列。  

![LCS](/images/blog/LCS.png)  

我之前一直以为公共子序列必须得是连续的...这次算颠覆了我的认知，如上图的两个例子，公共子序列既可以是连续的也可以是分散的（has gaps）。  

打表过程如下：  

![LCS2](/images/blog/LCS2.png)  


实现代码如下：  
```c++
#include <iostream>
#include <cstring>
using namespace std;

int dp[20][20];

int main(int argc, const char * argv[]) {
    string a,b;
    cin>>a>>b;
    memset(dp, 0, sizeof(dp));
    for(int i=1;i<=a.size();i++)
        for(int j=1;j<=b.size();j++){
            if(a[i-1] == b[j-1]){
                dp[i][j] = 1+dp[i-1][j-1];
            }
            else{
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
    cout<<dp[a.size()][b.size()]<<endl;
    return 0;
}
```


**与之前所学的动态规划问题进行类比（二维）**  
1.有着同样的初始化操作，将二维表的横纵设置为0.  
2.其考虑的都是从最开始的状态起，到目标状态的情况，但是不同的问题具有不同的递推方程，也就是具体到打表是不一样的。  

>例如01背包问题，  
>递推方程的两部分分别是：  
>1.如果我此时物品的重量大于背包容量，那我拿不了，此时我能受益的最大价值就是我抉择上一个物品时留下的状态   
>2.如果我此时能拿下这个物品，那我最大收益就是 Max（不拿这个物品，类似于1的情况，更小的空间+这个物品的价值）  

>LCS问题：  
>递推方程是：  
>1.如果这两个字符不相等，那么最长公共子序列是 Max（去掉s1的last字符，去掉s2的last字符）。 
>2.若果是两个字符相等，那个最长公共子序列就是 1+LSC（remove掉s1的last，remove掉s2的last）。 

从这两个问题中我的思考与总结是：  

>动态规划的题型还是十分灵活的，在考虑到这个现实问题是否可以由动态规划来解决就非常需要分析能力，其次动态规划问题并不是千篇一律的简单打表，当上升到二维的打表时，我们必须清楚这个cell的依据是什么，庆幸的是，仍然是有相同之处：比如初始化的时候两条表格都为0，最右下角的cell就是我们要求的东西，区别在于针对每一个cell其递推过程可能有所差异，需要针对不同的题型具体分析，动态规划是一类乍一看十分懵的题，如果这个题一看就束手无策，在还有时间做的情况下，需要优先考虑动态规划。  


---


