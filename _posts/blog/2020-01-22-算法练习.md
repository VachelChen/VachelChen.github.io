---
layout: post
title: 算法练习
categories: 算法
description: 身为一个程序员可以说数据结构以及算法知识是基本功了，此次为了本科期间最后一次征战蓝桥杯能去得理想的成绩，我决定全力以赴，争取拿到一个国家级的名次。
keywords: 数据结构,蓝桥杯，ACM
---

数据结构和算法是程序员的基本功，也是各大学校各大厂十分看重的敲门砖，本人参与过一些竞赛，竞赛除了考察对数据结构的掌握其实还存在许多的套路，这里进行一个总结与归纳，希望可以在日后参加竞赛时去得更好的成绩。

## 常见问题知识储备

**C语言数组放在main函数里面和外面的区别**  

几个概念：    

栈区：由操作系统自动分配释放，存放函数的参数值，局部变量的值；当不需要时系统会自动清除。  

堆区：由new分配的内存块，不由编译器管，由应用程序控制（相当于程序员控制）。如果程序员没有释放掉，程序结束后，操作系统会自动回收。  

数据区：也称全局区或者静态区，存放全局的东西类似全局变量。  

代码区：存放执行代码的地方，类似if else，while，for这种语句。  

在main函数里面的数组是开在栈区(stack)，在函数外面的是开在数据区的。栈区的内存比较小，所以当数组非常大的时候，就会报错。假如把数组放在数据区就不会出现这个问题，因为数据区的内存很大。

```c
#include <iostream>
using namespace std;

//main函数外为数据区，差不多是真实计算的内存大小
long long a[20190325];


int main(int argc, const char * argv[]) {
    // insert code here...
    //main函数内 为栈区 内存块比较小
    a[1]=1;
    a[2]=1;
    a[3]=1;
    for(long long i=4;i<=20190325;i++){
        a[i]=(a[i-1]+a[i-2]+a[i-3])%10000;
    }
    cout<<a[20190324]<<endl;
    return 0;
}
```



**C++题目开数组下标确定**  
绝大部分题目会给出数组的上限指标，但是当数组界限未给定时要自行运算一下，就比如2013年蓝桥省赛中大臣的旅费一题，其中没有给定要输入的n（表示城市数）的规模，我在自己的Xcode上演算无误后提交却一直出现运行错误的问题。  

查阅资料后发现蓝桥杯最大栈空间为256MB，于是我进行了如下演算：  

![shuzu](/images/blog/shuzu.png)  

得出如下结论：*最大可以开1乘10的7次方左右的数组空间*  

```c
	//合理开辟方法例子如下：
	int a[10000000]; //二维数组最大合理大小

	int a[1000][1000];	//二维数组最大合理大小
```



**int形最大存储位数**  
int为4字节，也就是共32位存储，可以存储负数说明第一位用来存储符号，所以其表示范围为：  
```c
	-2^31~2^31
	2^31 = 2 147 483 648 (10位数)
```
ps : 值得注意的是，当两个int进行类似乘或者平方等位数增长类运算时，若突破10位后再用long long接收是接收不到正确的数字的，只能接收益处的数字，*所以当面临溢出风险时最好在运算前直接设为long long型*  



**Excel日期计算**  
Excel可以帮助我们对日期直接进行加减天数的计算，但是只识别1900-1-1日之后的日期。



**闰年判断**  
闰年的判断其实有两个条件：  
1.年份能被4整除但是不能被100整除,例如4  
2.年份能被400整除，例如400  
ps：之前混淆，其实这两个条件并不冲突，这两个条件不是要求同时满足，是满足一个即是闰年。  



## 常见问题解决套路

**string中的.find方法详解**  
用来寻找一个字符串中是否含有子串或子字符，常使用如下：  
```c++
母串.find(子串或子字符)！=string::npos  
```
其中 string::npos 表示没有找到。  



**数字字符(int)对字符(char)的相互转换**  
由于int+或-char类型可以直接转换为char类型，所以常借助ascii码表数字排位第一的'0'字符来转换：  

```c++
//将1转换为'1'
	char yi = 1+'0';
//将'1'转换为1
	int yi = '1'-'0';
```



**数字字符串(int)对字符串(string)的相互转换**  
```c++
#include<sstream>

//数字转换成字符串
void i2s(int x,string &str){
	stringstream ss;
	ss << x;
	ss >> str;
}

//字符串转换成数字
void s2i(int &x,string str){
	stringstream ss;
	ss << str;
	ss >> x;
}

```



**接收不确定的输入长度回车截止**  
有时会输入不确定个数的数字，以空格隔开，以回车结束，由于c没有java那样直接对字符串分割的函数

```c++
#include<sstream>

const int Maxn = 10000;


int data[Maxn];
string s;

getline(cin,s);	//先按行接收 若是之前有输入记得用 getchar()接收回车
istringstream iss(s);

string temp;

//getline 其实自带分割
//但是第一个参数需要使用istringstream
//第三个参数确定分割依据
//第二个参数确定存入哪里

while(getline(iss,temp,' ')){	
	//进行存储
	s2i(tmp,data[index++]);
}
```



## 一、枚举及全排列

**数字位全排列**  
对一串指定长度为n的数字要对每一位做全排列的话，若直接使用n位最小数字到n位最大数字的一个for循环，在取出每一位上数字时会较为麻烦，这时候推荐采用n个for循环，在每一个循环中添加约束条件会比较清晰。  
```c++

//取各位都不一样的六位数

//推荐做法：
for (int i = 1; i < 10; ++i) {
        for (int j = 0; j < 10; ++j) {
            if (j != i)
                for (int k = 0; k < 10; ++k) {
                    if (k != i && k != j)
                        for (int l = 0; l < 10; ++l) {
                            if (l != i && l != j && l != k)
                                for (int m = 0; m < 10; ++m) {
                                    if (m != i && m != j && m != k && m != l)
                                        for (int n = 0; n < 10; ++n) {
                                            if (n != i && n != j && n != k && n != l && n != m) {
                                                long long x = i * 100000 + j * 10000 + k * 1000 + l * 100 + m * 10 + n;
                                                if (check(x, x * x)) {
                                                    cout << x << " " << x * x << endl;
                                                }
                                            }
                                        }
                                }
                        }
                }
        }
    }

//我的做法

for(long long i=123456;i<=987654;i++)
    {
        liu = i%10;
        wu = (i-liu)%100/10;
        si = (i-wu*10-liu)%1000/100;
        san = (i-si*100-wu*10-liu)%10000/1000;
        er = (i-san*1000-si*100-wu*10-liu)%100000/10000;
        yi = (i-er*10000-san*1000-si*100-wu*10-liu)/100000;
        if(liu==wu || liu==si || liu==san || liu==er || liu==yi || wu==si || wu==san || wu==er || wu==yi || si==san || si==er || si==yi || san==er || san==yi || er==yi)
            continue;
        //····
    }



```




---

## 二、大数运算

---

## 三、快排

---

## 四、图论

### DFS、


### BFS、

**stl中queue常用函数**  

想要用好bfs，用stl模版库中的现成队列再方便不过，这里总结一下队列中的函数：  

```c
#include <queue>

queue <datatype> q;

q.empty();	//判断队列是否为空

q.size();	//访问队列q的元素个数

q.push(a);	//讲一个元素a放入队列

q.front();	//返回队列的第一个元素

q.pop();	//移除队列的第一个元素


```



**BFS做题框架与应用场景**  
重练蓝桥19年省赛题目 迷宫，当时赛场上觉得撞到宝了，和13年的爱我中华差不多，虽然其让输出最短路径，我就把所有路径都找到排个序输出排头兵就行，但是数据量一直很大导致当时根本没有得处结果，这时候我才明白：  

*找迷宫出口、包括找最短迷宫出口这都是使用BFS来干的事*  

（说实话只在课本上学过，一直没遇到过BFS实战的题目，没想到第一次见就是在赛场上，真是教训）

BFS大致框架如下：

学习数据结构时都知道BFS和队列有关，DFS和栈有关，想着自己在使用DFS时基本根本没有使用到
<stack>结构，后知后觉才反应过来自己用的递归不就是栈吗？而BFS在实战时似乎就必须要使用队列，一般不会选自己去创建队列，stl模版库它不香吗？

```c++
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=100;
bool vst[maxn][maxn]; // 访问标记

//虽然在我使用dfs的时候不喜欢用方向向量，但发现还是使用方向向量比较简洁

int dir[4][2]={0,1,0,-1,1,0,-1,0}; // 方向向量

// 在走迷宫一类问题中，放入队列的就是位置信息

struct State // BFS 队列中的状态数据结构
{
   int x,y; // 坐标位置
   int Step_Counter; // 搜索步数统计器
};
 
 
State a[maxn];
 
 
bool CheckState(State s) // 约束条件检验
{
   if(!vst[s.x][s.y] && ...) // 满足条件
     return 1;
   else // 约束条件冲突
    return 0;
}
 
 
void bfs(State st)
{
     queue <State> q; // BFS 队列
     State now,next; // 定义2 个状态，当前和下一个
     st.Step_Counter=0; // 计数器清零
     q.push(st); // 入队
     vst[st.x][st.y]=1; // 访问标记

     //采用while来完成对地图的遍历
     while(!q.empty())
     {
       now=q.front(); // 取队首元素进行扩展
       if(now==G) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可
       {
         ...... // 做相关处理
        return;
       }
       for(int i=0;i<4;i++)
       {
         next.x=now.x+dir[i][0]; // 按照规则生成下一个状态
         next.y=now.y+dir[i][1];
         next.Step_Counter=now.Step_Counter+1; // 计数器加1
         if(CheckState(next)) // 如果状态满足约束条件则入队
          {
          q.push(next);
          vst[next.x][next.y]=1; //访问标记
          }
       }
     q.pop(); // 队首元素出队
  }
 return;
}
 
 
int main()
{
  ......
  return 0;
}


```

**模拟走迷宫**  

主干仍然是BFS框架，为了方便记录一般再使用一张地图（已经是第三次使用地图，第一次地图用来记录地形，第二次用来记录访问情况），而此时这里的地图用来记录：*当到这个点时，是怎么从上一个点过来的*  

而一般对于填空题来说，答案是唯一的，当有多条路径可以选择时一般题目会强调按字典序排，对于BFS第一轮找到的一定是最短路径这不用多说，但是如何保证是最短的呢？一开始我还对这个问题有所纠结，后来仔细一想发现只要我调整BFS在四个方向的遍历顺序满足字典顺序，就可以达到目标效果。

附上2019_迷宫：
```c
//
//  main.cpp
//  2019_迷宫
//
//  Created by VachelChen on 2020/2/3.
//  Copyright © 2020 VachelChen. All rights reserved.
//

//下图给出了一个迷宫的平面图，其中标记为1 的为障碍，标记为0 的为可
//以通行的地方。
//010000
//000100
//001001
//110000
//迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这
//个它的上、下、左、右四个方向之一。
//对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，
//一共10 步。其中D、U、L、R 分别表示向下、向上、向左、向右走。
//对于下面这个更复杂的迷宫（30 行50 列），请找出一种通过迷宫的方式，
//其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。
//请注意在字典序中D<L<R<U。（如果你把以下文字复制到文本文件中，请务
//必检查复制的内容是否与文档中的一致。在试题目录下有一个文件maze.txt，
//内容与下面的文本相同）
//(每行50个数字，格式不对的话需要自己去调整)
/*
01010101001011001001010110010110100100001000101010
00001000100000101010010000100000001001100110100101
01111011010010001000001101001011100011000000010000
01000000001010100011010000101000001010101011001011
00011111000000101000010010100010100000101100000000
11001000110101000010101100011010011010101011110111
00011011010101001001001010000001000101001110000000
10100000101000100110101010111110011000010000111010
00111000001010100001100010000001000101001100001001
11000110100001110010001001010101010101010001101000
00010000100100000101001010101110100010101010000101
11100100101001001000010000010101010100100100010100
00000010000000101011001111010001100000101010100011
10101010011100001000011000010110011110110100001000
10101010100001101010100101000010100000111011101001
10000000101100010000101100101101001011100000000100
10101001000000010100100001000100000100011110101001
00101001010101101001010100011010101101110000110101
11001010000100001100000010100101000001000111000010
00001000110000110101101000000100101001001000011101
10100101000101000000001110110010110101101010100001
00101000010000110101010000100010001001000100010101
10100001000110010001000010101001010101011111010010
00000100101000000110010100101001000001000000000010
11010000001001110111001001000011101001011011101000
00000110100010001000100000001000011101000000110011
10101000101000100010001111100010101001010000001000
10000010100101001010110000000100101010001011101000
00111100001000010000000110111000000001000000001011
10000001100111010111010001000110111010101101111000
 */

#include <iostream>
#include <queue>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;

char a[31][51];
int visit[31][51]={0};
char where[31][51];
int n,m;

struct state{
    int x,y;
    state(int _x,int _y){
        x=_x;
        y=_y;
    }
};

void bfs(){
    queue<state> q;
    q.push(state(0,0));
    visit[0][0]=1;
    where[0][0]='S';
    while(!q.empty()){
        state temp = q.front();
        q.pop();
        if(temp.x == n-1 && temp.y == m-1)  break;
        if(temp.x < n-1 && !visit[temp.x+1][temp.y] && a[temp.x+1][temp.y] != '1' ) {
            visit[temp.x+1][temp.y]=1;
            q.push(state(temp.x+1,temp.y));
            where[temp.x+1][temp.y]='D';
        }
        
        if(temp.y > 0 && visit[temp.x][temp.y-1]!=1 && a[temp.x][temp.y-1]!='1') {
            visit[temp.x][temp.y-1]=1;
            q.push(state(temp.x,temp.y-1));
            where[temp.x][temp.y-1]='L';
        }
        
        if(temp.y < m-1 && visit[temp.x][temp.y+1]!=1 && a[temp.x][temp.y+1]!= '1') {
            visit[temp.x][temp.y+1]=1;
            q.push(state(temp.x,temp.y+1));
            where[temp.x][temp.y+1]='R';
        }
        
        if(temp.x > 0 && visit[temp.x-1][temp.y]!=1 && a[temp.x-1][temp.y]!='1') {
            visit[temp.x-1][temp.y]=1;
            q.push(state(temp.x-1,temp.y));
            where[temp.x-1][temp.y]='U';
        }
        
        
    }
}

int main(int argc, const char * argv[]) {
    // insert code here...
    cin>>n; cin>>m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++){
            cin>>a[i][j];
        }
    
//    cout<<endl;
//    for(int i=0;i<n;i++)
//        for(int j=0;j<m;j++){
//            cout<<a[i][j];
//        }
    
    bfs();
    
    char ans[1000];
    int ansindex=0;
    int x=n-1,y=m-1;
    while(where[x][y]!='S'){
        ans[ansindex++]=where[x][y];
        if(where[x][y] == 'D')
            x=x-1;
        else if(where[x][y] == 'U')
            x=x+1;
        else if(where[x][y] == 'R')
            y=y-1;
        else if(where[x][y] == 'L')
            y=y+1;
    }
    for(int i=ansindex-1;i>=0;i--)
        cout<<ans[i];
    cout<<endl;
    return 0;
}

```


---

## 五、树

---

## 六、动态规划

---


