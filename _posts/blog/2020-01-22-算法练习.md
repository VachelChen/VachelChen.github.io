---
layout: post
title: 算法练习
categories: 算法
description: 身为一个程序员可以说数据结构以及算法知识是基本功了，此次为了本科期间最后一次征战蓝桥杯能去得理想的成绩，我决定全力以赴，争取拿到一个国家级的名次。
keywords: 数据结构,蓝桥杯，ACM
---

数据结构和算法是程序员的基本功，也是各大学校各大厂十分看重的敲门砖，这里进行一个统一总结。

## 常见问题知识储备

**int形最大存储位数**  
int为4字节，也就是共32位存储，可以存储负数说明第一位用来存储符号，所以其表示范围为：  
```c
	-2^31~2^31
	2^31 = 2 147 483 648 (10位数)
```
ps : 值得注意的是，当两个int进行类似乘或者平方等位数增长类运算时，若突破10位后再用long long接收是接收不到正确的数字的，只能接收益处的数字，*所以当面临溢出风险时最好在运算前直接设为long long型*  


**Excel日期计算**  
Excel可以帮助我们对日期直接进行加减天数的计算，但是只识别1900-1-1日之后的日期。


**闰年判断**  
闰年的判断其实有两个条件：  
1.年份能被4整除但是不能被100整除,例如4  
2.年份能被400整除，例如400  
ps：之前混淆，其实这两个条件并不冲突，这两个条件不是要求同时满足，是满足一个即是闰年。  


## 常见问题解决套路

**string中的.find方法详解**  
用来寻找一个字符串中是否含有子串或子字符，常使用如下：  
```c++
母串.find(子串或子字符)！=string::npos  
```
其中 string::npos 表示没有找到。  


**数字字符(int)对字符(char)的相互转换**  
由于int+或-char类型可以直接转换为char类型，所以常借助ascii码表数字排位第一的'0'字符来转换：  

```c++
//将1转换为'1'
	char yi = 1+'0';
//将'1'转换为1
	int yi = '1'-'0';
```


**数字字符串(int)对字符串(string)的相互转换**  
```c++
#include<sstream>

//数字转换成字符串
void i2s(int x,string &str){
	stringstream ss;
	ss << x;
	ss >> str;
}

//字符串转换成数字
void s2i(int &x,string str){
	stringstream ss;
	ss << str;
	ss >> x;
}

```



## 一、枚举及全排列

**数字位全排列**  
对一串指定长度为n的数字要对每一位做全排列的话，若直接使用n位最小数字到n位最大数字的一个for循环，在取出每一位上数字时会较为麻烦，这时候推荐采用n个for循环，在每一个循环中添加约束条件会比较清晰。  
```c++

//取各位都不一样的六位数

//推荐做法：
for (int i = 1; i < 10; ++i) {
        for (int j = 0; j < 10; ++j) {
            if (j != i)
                for (int k = 0; k < 10; ++k) {
                    if (k != i && k != j)
                        for (int l = 0; l < 10; ++l) {
                            if (l != i && l != j && l != k)
                                for (int m = 0; m < 10; ++m) {
                                    if (m != i && m != j && m != k && m != l)
                                        for (int n = 0; n < 10; ++n) {
                                            if (n != i && n != j && n != k && n != l && n != m) {
                                                long long x = i * 100000 + j * 10000 + k * 1000 + l * 100 + m * 10 + n;
                                                if (check(x, x * x)) {
                                                    cout << x << " " << x * x << endl;
                                                }
                                            }
                                        }
                                }
                        }
                }
        }
    }

//我的做法

for(long long i=123456;i<=987654;i++)
    {
        liu = i%10;
        wu = (i-liu)%100/10;
        si = (i-wu*10-liu)%1000/100;
        san = (i-si*100-wu*10-liu)%10000/1000;
        er = (i-san*1000-si*100-wu*10-liu)%100000/10000;
        yi = (i-er*10000-san*1000-si*100-wu*10-liu)/100000;
        if(liu==wu || liu==si || liu==san || liu==er || liu==yi || wu==si || wu==san || wu==er || wu==yi || si==san || si==er || si==yi || san==er || san==yi || er==yi)
            continue;
        //····
    }



```




---

## 二、大数运算

---

## 三、快排

---

## 四、图论

### DFS、


### BFS、

---

## 五、树

---

## 六、动态规划

---


