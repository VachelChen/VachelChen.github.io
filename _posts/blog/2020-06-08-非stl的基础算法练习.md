---
layout: post
title: 非stl的基础算法练习
categories: Blog
description: 准备机试，尼玛居然不让用stl。
keywords: 算法, C语言
---
数据结构是重中之重，但是由于我在练习或比赛时一直对stl的频繁使用，似乎让我越来越对基础数据结构的代码能力越来越薄弱，由此重新开始练习基础。  
以《数据结构C（第二版）》严蔚敏、李冬梅老师书为训练基础。  

## 复杂度  

**时间复杂度**  
其实就是找循环和n有关的执行次数。
logn2的时间复杂度：   
```c++
for(int i=0;i<=n;i=i*2){
	x++;
}

//2^n<=n   f(n)=log2n 
```
**空间复杂度**  
其实就是找需要借助的大小n的复杂度  
例如逆序交换时只用一个数，与n的规模无关，则为O1。  
若是要用n大小数组，则为On。

## 程序设计要点  

1.不允许使用stl库，所以所有的数据结构都要自己编写所以基本用C来完成。  
2.对异常情况的处理，由于数据结构的书中会考虑许多不满足条件的情况以增加程序健壮性，所以基本上函数都是有int型返回值的，虽然不一定接受，可能这样更严谨吧。  

```c
//常用的返回值大概有三类
#define ok 1
#define error 0
#define overflow -2  
```


## 线性表   
线性表中主要有两种结构：顺序表和链表。  

### 顺序表   
顺序表指的是用一组地址连续的存储单元依次存储线性表的数据元素。  

**顺序表的存储结构**  
线性表可以根据需要增长或缩短，所以并不是简单的数组可以用来表示（在C语言中数组的给定需要提前给出长度，所以这里的感觉更像是stl中的vector）。  

```c++
const int  
struct sqlist{
	node *elem;		//当前空间的基地址
	int length;		//当前长度
};
```

**顺序表的初始化**  
完成两件事：  

1.为顺序表L分配一个预定大小的数组空间maxn（涉及内存分配的问题需要使用if来判断一下是否分配失败），用elem指向这段空间的基地址。   

2.将长度length设为0。   

```c++
int InitList(sqlist &L){
	L.elem = new node[Mansize];
	if(!L.elem) return overflow;
	L.length = 0;
	return ok;
};
```

**顺序表的取值**  
完成两件事：  

1.判断指定的位置序号是否合理（1<=i<=L.length）;

2.若i合理则返回给一个&数;

```c++
int GetElem(sqlist &L,int i,node &e){
	if(i<1 || L.length)	return error;
	e = L.elem[i-1];
	return ok;
}
```

**顺序表的查找**  
返回查找到的序号  
完成两件事：  

1.依次比较，相等则返回序号   

2.找不到返回0  
```c++
int find(sqlist &L,node e){
	for(int i=0;i<L.length;i++)
		if(L.elem[i] == e)	return i+1;
	return 0;
}
```


**顺序表的插入**  
返回查找到的序号  
完成五件事：  
1.判断插入位置是否合法。  
2.判断存储空间是否已满。
3.将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置。   
4.放入元素在第i个位置。   
5.表长加1。  

```c++
int LisrInsert(sqlist &L,int i,node e){
	if((i<1)||(i>L.length+1))	return error;
	if(L.length == Mansize) return error;
	for (int j = L.length-1; j > i-1 ; j--)
	{
		/* code */
		L.elem[j+1]=L.elem[j];
	}
	L.elem[i-1]=e;
	L.length++;
	return ok;
}

```

**顺序表的删除**  
返回查找到的序号  
完成三件事：  
1.删除位置是否合法。  
2.i+1个往前移。
3.表长减1。   

```c++
int LisrDelete(sqlist &L,int i){
	if (i<1||i>L.length)	return ERROR;
	for (int j = i; j<= L.length-1; i++)
	{
		L.elem[j-1]=L.elem[j];
	}
	L.length--;
	return ok;
}

```


### 链表   
顺序表指的是用一组地址任意的（可连续，可不连续）存储单元依次存储线性表的数据元素。   

**链表的存储结构**  
线性表可以根据需要增长或缩短，所以并不是简单的数组可以用来表示（在C语言中数组的给定需要提前给出长度，所以这里的感觉更像是stl中的vector）。  

```c++
const int  
typedef struct Lnode{
	elem data;		//当前空间的基地址
	Lnode *next;		//当前长度
}Lnode,*LinkList;
```

**单链表的初始化**   
其实就是完成对头节点的初始化。  
```c++
void InitList(LinkList &l){
	l = new Lnode;
	l->next = NULL;
}

```

**单链表的取值**   
1.用指针p指向首元节点。计数器j=1.  
2.只要p不为NULL并且未到达i，p就指向下一个节点，并且计数器+1.
3.若p为NULL或j大于i这失败，若成功则改变参数e.  
```c++
int GetElem(LinkList &l,int i,elem &e){
	LinkList p;
	p = l->next;j=1;
	while(p && j<i){
		p=p->next;
		j++;
	}
	if(!p||j>i)	return error;
	e = p->data;
	return ok;
}

```

**单链表的查找**   
1.p指向首元节点.  
2.只要p不为NULL并且不等于e，p就指向下一个节点.
3.若p为NULL或j大于i这失败，若成功则改变参数e.  
```c
int GetElem(LinkList l,int i,elem e){
	LinkList p;
	p = l->next;
	while(p && p->data != e){
		p=p->next;
	}
	return p;
}

```


**单链表的插入**   
1.查找节点i-1并让p指向.  
2.生成一个新节点s.  
3.将数据域设为e.  
4.将新节点的指针域指向i.  
5.将p指向s.   
```c
int GetElem(LinkList &l,int i,elem &e){
	LinkList p,s;
	p = l->next;j=0;
	while(p && j<i-1){
		p=p->next;
		j++;
	}
	if(!p||j>i-1)	return error;
	s = new Lnode;
	s->node = e;
	s->next = p->next;
	p->next = s;
	return ok;
}

```


**单链表的删除**   
1.查找节点i-1并让p指向.  
2.临时保存待删结点i的地址在q中，以备释放.  
3.将节点p的指针域指向i的直接后继节点.  
4.将新节点的指针域指向i.  
```c
int GetElem(LinkList &l,int i){
	LinkList p,q;
	p = l->next;j=0;
	while(p && j<i-1){
		p=p->next;
		j++;
	}
	if(!p||j>i-1)	return error;
	q=p->next;
	p->next = q->next;
	delete q;
	return ok;
}

```

**单链表的创建**   
之前顺序表的创建是可以直接赋值的，但是链表的创建一般是靠两种方法。  
（1）前插法   
将节点插入头节点之后来创建链表的方法。  
1.首先初始化，得到一个只有头节点的空链表。  
2.循环n次：生成一个新节点p，输入数据域，将p插入到头节点之后。  
ps：需要注意的是，由于每次插入是在头部，所以需要逆序输入数据。  

```c
void creat_h(LinkList &l,int n){
	l = new Lnode;
	l->next = NULL;
	for (int i = 0; i < n; ++i)
	{
		p = new Lnode;
		cin >> p->data;
		p->next = l->next;
		l->next = p;
	}
}


```

(2)后插法  
为了使每次都插到最后需要一个尾指针。  
1.首先初始化，得到一个只有头节点的空链表。  
2.尾指针r初始化，指向头节点。  
3.循环n次：生成一个新节点p，输入数据域，指针域为空，将新节点p插入到尾节点r之后，指针r指向尾节点p。  

```c
void creat_r(LinkList &l,int n){
	l = new Lnode;
	l->next = NULL;
	LinkList r,p;
	r = l;
	for (int i = 0; i < n; ++i)
	{
		p = new Lnode;
		cin >> p->data;
		p->next = NULL;
		r->next = p;
		r=p;
	}
}

```








