---
layout: post
title: 非stl的基础算法练习
categories: Blog
description: 准备机试，尼玛居然不让用stl。
keywords: 算法, C语言
---
数据结构是重中之重，但是由于我在练习或比赛时一直对stl的频繁使用，似乎让我越来越对基础数据结构的代码能力越来越薄弱，由此重新开始练习基础。  
以《数据结构C（第二版）》严蔚敏、李冬梅老师书为训练基础。  

## 复杂度  

**时间复杂度**  
其实就是找循环和n有关的执行次数。
logn2的时间复杂度：   
```c++
for(int i=0;i<=n;i=i*2){
	x++;
}

//2^n<=n   f(n)=log2n 
```
**空间复杂度**  
其实就是找需要借助的大小n的复杂度  
例如逆序交换时只用一个数，与n的规模无关，则为O1。  
若是要用n大小数组，则为On。

## 程序设计要点  

1.不允许使用stl库，所以所有的数据结构都要自己编写所以基本用C来完成。  
2.对异常情况的处理，由于数据结构的书中会考虑许多不满足条件的情况以增加程序健壮性，所以基本上函数都是有int型返回值的，虽然不一定接受，可能这样更严谨吧。  

```c
//常用的返回值大概有三类
#define ok 1
#define error 0
#define overflow -2  
```


## 线性表   
线性表中主要有两种结构：顺序表和链表。  

### 顺序表   
顺序表指的是用一组地址连续的存储单元依次存储线性表的数据元素。  

**顺序表的存储结构**  
线性表可以根据需要增长或缩短，所以并不是简单的数组可以用来表示（在C语言中数组的给定需要提前给出长度，所以这里的感觉更像是stl中的vector）。  

```c++

struct sqlist{
	node *elem;		//当前空间的基地址
	int length;		//当前长度
};
```

**顺序表的初始化**  
完成两件事：  

1.为顺序表L分配一个预定大小的数组空间maxn（涉及内存分配的问题需要使用if来判断一下是否分配失败），用elem指向这段空间的基地址。   

2.将长度length设为0。   

```c++
int InitList(sqlist &L){
	L.elem = new node[Mansize];	//为顺序表分配存储空间
	if(!L.elem) return overflow;
	L.length = 0;
	return ok;
};
```

**顺序表的取值**  
完成两件事：  

1.判断指定的位置序号是否合理（1<=i<=L.length）;

2.若i合理则返回给一个&数;

```c++
int GetElem(sqlist &L,int i,node &e){
	if(i<1 || L.length)	return error;
	e = L.elem[i-1];
	return ok;
}
```

**顺序表的查找**  
返回查找到的序号  
完成两件事：  

1.依次比较，相等则返回序号   

2.找不到返回0  
```c++
int find(sqlist &L,node e){
	for(int i=0;i<L.length;i++)
		if(L.elem[i] == e)	return i+1;
	return 0;
}
```


**顺序表的插入**  
返回查找到的序号  
完成五件事：  
1.判断插入位置是否合法。  
2.判断存储空间是否已满。
3.将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置。   
4.放入元素在第i个位置。   
5.表长加1。  

```c++
int LisrInsert(sqlist &L,int i,node e){
	if((i<1)||(i>L.length+1))	return error;
	if(L.length == Mansize) return error;
	for (int j = L.length-1; j > i-1 ; j--)
	{
		/* code */
		L.elem[j+1]=L.elem[j];
	}
	L.elem[i-1]=e;
	L.length++;
	return ok;
}

```

**顺序表的删除**  
返回查找到的序号  
完成三件事：  
1.删除位置是否合法。  
2.i+1个往前移。
3.表长减1。   

```c++
int LisrDelete(sqlist &L,int i){
	if (i<1||i>L.length)	return ERROR;
	for (int j = i; j<= L.length-1; i++)
	{
		L.elem[j-1]=L.elem[j];
	}
	L.length--;
	return ok;
}

```


### 链表   
顺序表指的是用一组地址任意的（可连续，可不连续）存储单元依次存储线性表的数据元素。   

**链表的存储结构**  
线性表可以根据需要增长或缩短，所以并不是简单的数组可以用来表示（在C语言中数组的给定需要提前给出长度，所以这里的感觉更像是stl中的vector）。  

```c++
const int  
typedef struct Lnode{
	elem data;		//当前空间的基地址
	Lnode *next;		//当前长度
}Lnode,*LinkList;
```

**单链表的初始化**   
其实就是完成对头结点的初始化。  
```c++
void InitList(LinkList &l){
	l = new Lnode;
	l->next = NULL;
}

```

**单链表的取值**   
1.用指针p指向首元结点。计数器j=1.  
2.只要p不为NULL并且未到达i，p就指向下一个结点，并且计数器+1.
3.若p为NULL或j大于i这失败，若成功则改变参数e.  
```c++
int GetElem(LinkList &l,int i,elem &e){
	LinkList p;
	p = l->next;j=1;
	while(p && j<i){
		p=p->next;
		j++;
	}
	if(!p||j>i)	return error;
	e = p->data;
	return ok;
}

```

**单链表的查找**   
1.p指向首元结点.  
2.只要p不为NULL并且不等于e，p就指向下一个结点.
3.若p为NULL或j大于i这失败，若成功则改变参数e.  
```c
int GetElem(LinkList l,int i,elem e){
	LinkList p;
	p = l->next;
	while(p && p->data != e){
		p=p->next;
	}
	return p;
}

```


**单链表的插入**   
1.查找结点i-1并让p指向.  
2.生成一个新结点s.  
3.将数据域设为e.  
4.将新结点的指针域指向i.  
5.将p指向s.   
```c
int GetElem(LinkList &l,int i,elem &e){
	LinkList p,s;
	p = l->next;j=0;
	while(p && j<i-1){
		p=p->next;
		j++;
	}
	if(!p||j>i-1)	return error;
	s = new Lnode;
	s->node = e;
	s->next = p->next;
	p->next = s;
	return ok;
}

```


**单链表的删除**   
1.查找结点i-1并让p指向.  
2.临时保存待删结点i的地址在q中，以备释放.  
3.将结点p的指针域指向i的直接后继结点.  
4.将新结点的指针域指向i.  
```c
int GetElem(LinkList &l,int i){
	LinkList p,q;
	p = l->next;j=0;
	while(p && j<i-1){
		p=p->next;
		j++;
	}
	if(!p||j>i-1)	return error;
	q=p->next;
	p->next = q->next;
	delete q;
	return ok;
}

```

**单链表的创建**   
之前顺序表的创建是可以直接赋值的，但是链表的创建一般是靠两种方法。  
（1）前插法   
将结点插入头结点之后来创建链表的方法。  
1.首先初始化，得到一个只有头结点的空链表。  
2.循环n次：生成一个新结点p，输入数据域，将p插入到头结点之后。  
ps：需要注意的是，由于每次插入是在头部，所以需要逆序输入数据。  

```c
void creat_h(LinkList &l,int n){
	l = new Lnode;
	l->next = NULL;
	for (int i = 0; i < n; ++i)
	{
		p = new Lnode;
		cin >> p->data;
		p->next = l->next;
		l->next = p;
	}
}


```

(2)后插法  
为了使每次都插到最后需要一个尾指针。  
1.首先初始化，得到一个只有头结点的空链表。  
2.尾指针r初始化，指向头结点。  
3.循环n次：生成一个新结点p，输入数据域，指针域为空，将新结点p插入到尾结点r之后，指针r指向尾结点p。  

```c
void creat_r(LinkList &l,int n){
	l = new Lnode;
	l->next = NULL;
	LinkList r,p;
	r = l;
	for (int i = 0; i < n; ++i)
	{
		p = new Lnode;
		cin >> p->data;
		p->next = NULL;
		r->next = p;
		r=p;
	}
}

```

**链表的排序**  
总的来说还是冒泡排序，但是不能像顺序表那样直接选择这时候就需要再使用一个指针来代替。  

```c++

for(int i=0; i<l.length-1 ;i++){
	//i、j次数不变，但是需要用指针指到第一个数据
	LinkList p = l->next;
	for (int j = 0; j < l.length-i-1 ; j++)
	{
		if (p->data.price < p->next->data.price) {
                //并不需要复杂的换位置，直接交换结点数据内容即可
                book t = p->data;
                p->data = p->next->data;
                p->next->data = t;
            }
   		p=p->next;
   		//通过指向下一个来完成一次循环中的向后迁移
	}
}

```

**单链表的逆序**  
单链表的逆序最少需要用到四个指针，头指针l，h=l，t=h->next,s=t->next;   
完成指针指向的逆转，而不仅仅还是data的换位，逆转后把头指针移到末尾，头结点还在原来的位置，所以当输出时要提前判定一个node位。  



**查找两个单词链表共同后缀的起始结点**    
使用前插法得到倒序的单词序列，在遍历时需要提前一个节点进行检查，若不想等则现在指向的节点就是答案。   





**循环链表**    
最后一个结点的指针指向头结点，也就意味着头节点其实背两个指针共同指向（头指针、最后一个结点的指针），也可以发现没有结点的next为NULL。   
没有结点时头节点的next也指向本身。  

循环链表在操作上与单链表差不多，但是遍历时需要判定的是p！=L。  


**双向链表**    
为了克服链表的单项性，设计双向链表，存储结构如下，多了直接前驱：  
```c++

typedef struct Lnode
{
	elem data;
	Lnode *prior;	//直接前驱
	Lnode *next;
}*LinkList;

```


**顺序表和链表比较**    

***空间性能***  
1.存储空间的分配   
顺序表存储空间需要先分配，扩充受限制，而且易造成空间浪费。当线性表长度变化大、难以预估存储规模时，宜采用链表作为存储结构。  

2.存储密度的大小  
链表的结点处了设置数据与用来存储元素外还需设置指针域，所以顺序表密度等于1，链表密度小于1。当线性表长度变化不大、事先确定大小时，为了节约空间适合采用顺序表作为存储结构。  


***时间性能***  

1.存取效率     
顺序表由数组实现，是一种随机存储结构，取值效率高。链表是一种顺序存储结构，存取元素时只能依次遍历，效率比较低。若需多次存取操作，最好选择顺序表。    

2.插入删除效率     
对于链表，在确定插入删除位置后，插入删除操作无需移动数据，只需修改指针。而顺序表的插入删除操作平均需要移动一半的节点，时间复杂度较高。因此若线性表需要频繁的进行插入删除操作，宜采用链表作为存储结构。  


**线性表应用**    

***线性表的合并***  
算法步骤：
1.分别获取A表长m，B表长n。  
2.从B中第一个元素开始，循环n次执行以下操作：  
	将B中的第i个元素赋给e。  
	将A中查找元素e，如果不存在就插在A的最后。  

相当于以一个链表为基准去遍历另一个链表一次，时间复杂度为O(nm)。  


***有序表的合并***  
1.顺序表的合并    
	创建一个m+n的空表C   
	pc初始化，指向C的第一个元素   
	pa、pb也初始化，指向A、B的第一个元素  
	当指针pa、pb均为到达相应表尾时，则依次比较pa和pb的元素值，从A、B中选择较小的插入到C最后   
	如果pb/pa到达尾部，将LA/LB的剩余元素插入LC之后  

不是很常用，因为空间复杂度较高。要点就是要重新创建一个顺序表。  


2.链表的合并    
算法步骤：  
	指针pa、pb分别指向A、B的第一个结点。  
	C的节点取值为LA的头结点。  
	pc初始化，指向C的头结点。  
	当指针pa合pb均未到达相应表尾时，依次比较pa、pb说指向元素的值，选择较小的元素值插入到C的最后。   
	将非空表剩余段插入到pc所指的结点之后。  
	释放B的头结点。  

```c++

void MergeList(LinkList &a,LinkList &b,LinkList &c){
	LinkList pa = a->next,pb = b->next,pc;
	c = a;
	pc = c;
	while(pa && pb){
		if (pa->data <= pb->data)
		{
			pc->next = pa;
			pc=pa;
			pa=pa->next;
		}
		else{
			pc->next = pb;
			pc=pb;
			pb=pb->next;
		}
	}
	pc->next=pa?pa:pb;
	delete b;
}

```


**案例分析**    

***一元多项式***  
一元线性表可以用数组来表示，数组分量下标i即对应每项的系数，再运算时只要把两个数组对应的分量相加即可。  


***稀疏多项式***  
稀疏多项式的相加过程和归并两个有序表的过程及其类似，此过程常用链式存储结构更加灵活，(有点类似于稀疏图使用邻接表，而不是用邻接矩阵来描述一样)更适合表示一般的多项式，其中结点要进行一些变化。  
```c++

typedef struct PNode{
	float c;			//系数
	int e;				//指数
	Pnode *next;		
}*LinkList;

```

由此，在稀疏多项式相加时可以模拟链表归并的过程，因为稀疏多项式的项顺序是以系数递增或递减排列的，

***OJ练习***   

## 栈和队列   
### 顺序栈   
仅能在表尾进行插入和删除操作的线性表。栈可以进栈和出栈的一端称为栈顶，最里面的一端称为栈底。

**顺序栈的表示和实现**   
顺序栈是指利用顺序存储结构实现的栈，结构体的创建类似于顺序表，里面存在指针变量，代表地址。顺序栈定义如下：  
```c
#define MAXSIZE 100

typedef struct
{
	ElemType *base;	//栈底指针，初始化完成后，base始终指向栈底为止
	ElemType *top;  //栈顶指针，初值指向栈底
	int stacksize;	//栈最大容量,s.top-s.base就可以得到容量
}SqStack;


```
![youpiao1](/images/blog/stack.png)  


**顺序栈的初始化**   
1.为顺序栈分配一个MAXSIZE的数组空间,并判断内存分配情况。  
2.使base指向这段空间的基地址，即栈底。  
3.top指向base，表示栈空。  
4.stacksize表示为最大容量MAXSIZE。   

```c

int InitStack(SqStack &s){
	s.base = new ElemType[MAXSIZE];
	if(!s.base) exit(error);
	s.top=s.base;	//top指针指向刚刚开辟的空间
	s.stacksize = MAXSIZE;	//stacksize保存的是最大容量
	return ok;
}

```

**顺序栈的入栈**   

1.判断栈是否满  
2.将元素压入栈顶，栈顶指针加1   

ps：指针变量支持自增和自减操作，例如指针变量p+1代表p所指的int型变量的下一个int型变量地址，所以由此也可以完成类似数组遍历的操作。    

```c

int Push(SqStack &s,ElemType e){
	if(s.top-s.base == s.stacksize) return error;
	*s.top++ = e;	//自增运算符的优先级高于*，此表达式等价于*(s.top++)=e;
	return ok;
}
```

**顺序栈的出栈**   
1.判断栈是否为空   
2.栈顶指针减1，栈顶元素出栈   

```c

int Pop(SqStack &s,ElemType &e){
	if(s.top == s.base)	return error;
	e = *--s.top;
	return ok;
}

```

**取栈顶元素**   
需判断非空情况。  
```c
ElemType Top(SqStack s){
	if (s.top!=s.base)
	{
		return *(s.top-1);
	}
}
```

### 链栈   
链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示。  

**链栈的表示和实现**   
为了方便栈的插入和删除，一般以链表的头部作为栈顶，所以没必要附加一个头结点。  
```c

typedef struct StackNode{
	ElemType data;
	StackNode *next;
}*LinkStack;

```

**链栈初始化**   
其实就是让指针指空即可，可以不用写为一个函数。    
```c
void InitStack(LinkStack &s){
	s = null;
}
```

**链栈的入栈**   
    
```c++

void Push(LinkStack &s,ElemType e){
	LinkStack p;
	p->data=e;
	p->next=s;
	s = n;
}

```

**取栈顶元素**   
    
```c++

ElemType Top(LinkStack s){
	if (s!=NULL)
		return s->data;
}

```

**案例分析**   
***数制的转换***   
由于数制转换的输出是需要从前至后遍历，所以可以借助栈结构来表示。  
```c++
//10进制转8进制 
void conversion(int N){
	InitStack(s);
	while(N){
		Push(s,N%8);
		N /= 8；
	}
	while(!stackEmpty(s)){
		Pop(S,e);
		cout<<e;
	}
}
```

***括号匹配***   
1.初始化一个空栈   
2.设置一标记性变量flag，用来标记匹配结果    
3.依次读入字符，若是'['或者'('则入栈。若是右括号，栈内非空且为相应的左括号则匹配成功   

```c++

bool matching(){
	InitStack(s);
	bool flag = true;
	cin >> ch;
	while(ch!='#' && flag){
		switch(ch){
			case'['||'(':	
				Push(s,ch);
				break;
			case']':
				if(!stackEmpty(s)&&Top(s)=='[')
					Pop(s,x);
				else
					flag = false;
				break;
			case')':
				if(!stackEmpty(s)&&Top(s)=='(')
				Pop(s,x);
				else
					flag = false;
				break;	
		}
		cin >> ch;
	}
	return flag;
}
```

***表达式求值***   
表达式由操作数、运算符和界限符组成。  
归纳运算规则为：  
1.先乘除，后加减。  
2.从左算到右。  
3.先括号内，后括号外。  

OPTR寄存运算符。  
OPND寄存操作数及运算结果。  

算法步骤：  
1.初始化OPTR和OPND栈，将表达式起始符“#”，压入OPTR栈。  
2.扫描表达式：读取第一个字符ch，如果表达式没有扫描完毕至“#”或OPTR的栈顶元素不为“#”时，则循环执行以下操作：  
	若ch不是运算符，压入OPND栈，读如下一字符ch；  
	若ch是运算符，根据OPTR的栈顶元素和ch的优先级比较结果做不同处理：
		若小于，则ch压入OPTR栈，读入下一字符ch；  
		若大于，则弹出OPTR栈顶元素，从OPND栈弹出两个数，进行相应运算，结果压入OPND栈。  
		若等于，则OPTR的栈顶元素是“（”且ch是“）”，这时弹出OPTR栈顶的“（”，相当于括号匹配成功，然后读入下一字符ch。  
3.OPND栈顶元素即为表达式求值的结果。  

```c++

//需要记下来   
char Percede(char a,char b){
    if ((a =='(' && b == ')')||(a == '='&&b == '='))
        return '=';    //括号和等号的情况为等于
    else if (a=='(' || a=='=' || b=='(' || ((a=='+'||a=='-') && (b=='*'||b=='/')))
        return '<';    //共四种小于情况：a、b的左括号情况，a的=情况，还有先乘除后加减的情况
    else
        return '>';
}


char EvaluateExpression(){
	InitStack(OPND);
	InitStack(OPTR);
	Push(OPTR,'#');
	cin >> ch;
	while(ch!='#'||getTop(OPTR)!='#')
	{
		if (!In(ch)) {Push(OPTR,ch);cin>>ch;}
		else
			switch(Precede(Top(OPTR),ch))
			{
				case '<':
					Push(OPTR,ch);cin>>ch;
					break;
				case '>':
					Pop(OPTR,theta);
					Pop(OPND,b);Pop(OPND,a);
					Push(OPND,Operate(a,theta,b));
					break;
				case '=':
					Pop(OPTR,x); cin>>ch;
					break;
			}
	}
	return Top(OPND);
}
```


***数学知识***   

后缀表达式：又称逆波兰表达式。运算方法为数字入栈，有运算符则出栈两个数运算。    


### 循环队列   

**队列的实现**   
```c++
#define MAXSIZE 100
typedef struct
{
	ElemType *base;	//存储空间的基地址
	int front;		//头元素的位置（后称头指针
	int rear;		//尾元素的位置（后称尾指针
}SqQueue;

```
初始化空队列时，front = rear = 0，每当插入一个元素时rear增1，每当删除队列头元素时候front就增加一。  
为了解决“假溢出”问题，需要巧妙的将顺序队列变为一个环状空间，称为循环队列。具体的运算时通过“模运算”来完成。   

![youpiao1](/images/blog/queue.png)  

由上图b发现若是所有元素都占满，那么队列的状态是q.front == q.rear，与空队相同，所以为了区分两种状态，队满时会少用一个空间来认为是队满。  
由此可以得到两个判断队列起始和终止状态的条件：  
>队空：q.front == q.rear  
>队满：(q.rear+1)%MAXQSIZE == q.front   


由于队列是队尾入队、队头出队，可能会导致“假溢出”现象，所以选择使用循环队列的方法来顺序表示和实现队列。  


**队列的初始化**   
1.分配数组空间，base指向首地址   
2.首尾指针相等且为0   

```c++

int InitQueue(SqQueue &q){
	q.base = new ElemType[MAXQSIZE];
	if(!q.base) return error;
	q.front = q.rear = 0;
	return ok;
}

```


**求队列长度**    

```c++

int QueueLength(SqQueue q){
	return (q.rear-q.front+MAXQSIZE)%MAXQSIZE;
}

```

**循环队列的入队**   
1.判断队列是否满  
2.将新元素插入队尾  
3.队尾指针加1  

```c++
int EnQueue(SqQueue &q,ElemType e){
	if((q.rear+1)%MAXQSIZE == q.front)	return error;
	q.base[q.rear] = e;
	q.rear = (q.rear+1)%MAXQSIZE;
	return ok;
}

```

**循环队列的出队**   
1.判断队列是否为空  
2.保存队头元素  
3.队头指针加1  

```c++
int DeQueue(SqQueue &q,ElemType &e){
	if(q.rear == q.front)	return error;
	e = q.base[q.front];
	q.front = (q.front+1)%MAXQSIZE;
	return ok;
}

```


**循环队列的头元素获取**   
只需先判断队列是否为空   

```c++
int DeQueue(SqQueue &q,ElemType &e){
	if(q.front != q.rear){
		return q.base[q.front];
	}
}

```


### 链队   
链队需要两个分别指向头尾的指针，线性表和单链表一样需要头节点（目前也就链栈不需要头节点）。    

![youpiao1](/images/blog/ListQueue.png)  

**链队的存储结构**   
```c++
//节点
typedef struct QNode{
	ElemType data;
	QNode *next;
}*QueuePtr;

//链队
typedef struct
{
	QueuePtr front;	//队头指针
	QueuePtr rear;	//队尾指针
}LinkList;

```

**链队的初始化**   
1.生成一个头结点，队头和队尾指针都指向此节点。  
2.头节点的指针域置空。    
```c++

void InitQueue(LinkList &q){
	q.front = q.rear = new QNode;
	q.front->next = NULL;
}

```

**链队的入队**   
```c++
void EnQueue(LinkList &q,ElemType e){
	QueuePtr p;
	p = new QNode;
	p->data = e;
	p->next = NULL;
	q.rear->next = p;
	q.rear = p;
}

```

**链队的出队**   
```c++
int DeQueue(LinkList &q,ElemType &e){
	if(q.front == q.rear) return error;
	QueuePtr p;
	p = q.front->next;
	e = p->data;
	q.front->next = p->next;
	if(q.rear == p) q.rear = q.front;	//最后一个元素被删，队尾指向头结点
	delete p;
	return ok;
}

```


**链队的出队**   
```c++
int DeQueue(LinkList &q,ElemType &e){
	if(q.front == q.rear) return error;
	QueuePtr p;
	p = q.front->next;
	e = q->data;
	q->front->next = p->next;
	if(q.rear == p) q.rear = q.front;
	delete p;
	return ok;
}

```

**链队的头元素**   
```c++
void Top(LinkList q){
	if (q.rear == q.front)
		return q.front->next->data;
}
```


**案例分析**   
***舞伴问题***   
对于伴舞配对问题，设置两个队列分别存放男士和女士，依次出队来配成舞伴，直至某队列变空为止。   

```c++
typedef struct
{
	char name[20];
	char sex;
}Person;
//------队列的顺序结构-------
#define MAXQSIZE 100
typedef struct
{
	Person *base;
	int front;
	int rear;
}SqQueue;
SqQueue Mdancers,Fdancers;

```

```c++

void DancePartner(Person dance[],int num){
	InitQueue(Mdancers);
	InitQueue(Fdancers);
	for (int i = 0; i < num; ++i)
	{
		p=dancer[i];
		if(p.sex=='F')	EnQueue(Fdancers,p);
		else EnQueue(Mdancers,p);
	}
	cout<<"The patners are:\n";
	while(!queueEmpty(Fdancers)&&!queueEmpty(Mdancers)){
		DeQueue(Fdancers,p);
		cout<<p.name<<" ";
		DeQueue(Mdancers,p);
		cout<<p.name<<endl;
	}
	if (!queueEmpty(Fdancers))
	{
		p=getTop(Fdancers)
		cout<<"The first women to get a partener is:"<<endl;
	}
	else if(!queueEmpty(Mdancers)){
		p=getTop(Mdancers);
		cout<<"The first man to get a partener is:"<<p.name<<endl;
	}
}




```


## 串、数组和广义表   
### 串的顺序存储   
串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。串和线性表的主要差别是在于基本操作中，线性表大多以单个元素为操作对象，例如在线性表中增删改查某个元素，串的基本操作中一般以串的整体作为操作对象，例如查找子串等。  

串一般采用顺序存储，进行如下描述：  
```c++

typedef struct{
	char ch[MAXQSIZE+1];
	int length;
}sstring;

```

BF算法：  
```c++
bool judge(string a,string b){
	//a是短的 b是长的
    int i=0,j=0;
    while (i<a.size() && j<b.size()) {
        if (a[i] == b[j]) {
            i++;j++;
        }
        else{
            j = j-i+1;
            i = 0;
        }
    }
    if(i==a.size()) return true;
    else return false;
}

```


## 树和二叉树   
### 二叉树性质   

对所有二叉树都成立：  
>1.在第i层上至多有2^(i-1)个节点。  
>2.深度为k的二叉树最大节点数为2^i-1个。  
>3.对任意一棵二叉树T，如果其终端节点数为n0，度为2的节点数n2，n0=n2+1。  

对完全二叉树（每个节点都和自己的位置对应，每层都满叫满二叉树）成立：  
>4.n个节点的完全二叉树的深度（层数）为 」log2n」+1.  
>5.如果对有一棵n个节点的完全二叉树的节点按层序编号从第一层开始编号，有如下性质：  
>（1）如果i=1，为根；如果i>1,其双亲是 」i/2」.  
>（2）如果2i>n，则无左孩子，否则左孩子为2i.    
>（3）如果2i+1>n，这无右孩子，否则右孩子是2i+1.  


### 二叉树的顺序存储结构   

顺序存储结构最大的特点就是使用一组地址连续的存储单元来存储数据元素，写的复杂其实就是用一个数组来表示，数组的大小就是节点的个数。  

```c++
#define maxsize 100
typedef ElemType SqBiTree[MAXSIZE];		//maxsize代表结点个数
SqBiTree bt;
```

二叉树节点会依照一定的规律存储进单元中：  
>1.对于完全二叉树只需要考虑编号为i的节点按层序存储进结构中。  
>2.一般二叉树的存储类似于完全二叉树，用0来表示不存在的节点。  
由此也可以看出顺序存储结构仅适用于完全二叉树。  


### 二叉树的链式存储结构   

最常见的二叉树链表的存储表示。  
```c++

typedef struct BiTNode{
	TElemType data;
	BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

```


### 遍历二叉树     

>先序遍历：  根->左->右  
>中序遍历：  左->根->右  
>后序遍历：  左->右->根   
以中序遍历为例，与先序遍历和后序遍历相比就是位置调换了。  
```c++
//递归表示
void InOrder(BiTree t){
	InOrder(t->left);
	cout<<t->data;
	InOrder(t->right);
}

//非递归表示
void InOrder(BiTree t){
	InitStack(S);
	p=T;
	q=new BiTNode;
	while(p||!stackEmpty(s)){
		if(p){
			Push(S,p);
			p=p->left;
		}
		else{
			Pop(S,q);
			cout<<q->data;
			p=q->right;
		}
	}
}
```

### 根据遍历确定二叉树     

之前的遍历是在已有二叉树的结构上遍历获取值，该过程是针对已有的遍历结果来创建二叉树，由于此过程需要说明为空的节点，所以可以用一个#自负表示空树。  

```c++

void CreateBiTree(BiTree &T){
	cin >> ch;
	if(ch == '#') T=NULL;
	else{
		T = new BiTNode;
		T->data = ch;			//复制二叉树也是同理，只是此处的值来源是树
		CreateBiTree(T->left);
		CreateBiTree(T->right);
	}
}

```


### 计算二叉树的深度   

采用递归的思想来完成，二叉树的深度为左右子树深度较大者加1.  

```c++

int Depth(BiTree T){
	if(T == NULL) return 0;
	else{
		int m = Depth(T->left);
		int n = Depth(T->right);
		if(m>n) return m+1;
		else return n+1;
	}
}

```

### 统计二叉树中节点的个数   

如果是空树放回0，否则就放回左子树+右子树+1（该节点）。  

```c++
int NodeCount(BiTree t){
	if(t == NULL)	return 0;
	else return NodeCount(t->left) + NodeCount(t->right)+1;
}
```   

### 线索二叉树   
>线索二叉树是什么？解决什么问题？  
在以二叉链表作为存储结构时，只能找到节点的左、右孩子信息，而不能直接得到节点在任一序列（前、中、后）中的前驱和后继信息，这种信息只有在便利的动态过程才能得到，引入线索二叉树就是为了保存在动态便利过程中得到的前驱和后继信息。  

>表示方式？  
由于每个节点中再增加两个指针域来表示前驱和后继会使得存储密度大大降低，而其实n个节点的二叉链表中必定存在n+1个空链域，因此利用空链域来存放节点的前驱和后继信息。  

>如何规定？   
```c++
typedef struct BiTreeNode{
	Elem data;
	BiThrTree *left,*right;
	int LTag,RTag;
	//LTag = 0 left指向左孩子  LTag = 1 left指向前驱
	//RTag = 0 right指向右孩子 RTag = 1 right指向后继 		
}BiTNode,*BiThrTree;
```
若节点有左子树，left就是指左孩子，否则令left指向前驱；若节点有右子树，则其right域指右孩子，否则令right域指向后继。 同时为了避免混淆，增加两个标志域LTag,RTag。


### 哈夫曼树    

1. 存储表示   
哈夫曼树又称最优树，是一类带权路径长度最短的树。根据给定的n个权值{w1,w2,···,wn},其实就是一直找最小的节点然后组成树（小的在左边，大的在右边）。  

```c++
typedef struct{
	int weight;
	int parent,left,right;
}HTNode,*HuffmanTree;

```

哈夫曼树的各节点存储在定义的动态分配的数组中，为了实现翻倍，数组的0号单元不适用，从1号单元开始使用，所以数组的大小为2n。 其中叶子节点在1～n个位置，后面的n-1个位置存储非叶子节点。  


2. 构造哈夫曼树  
构造哈夫曼树分为两部分(其实就是一个填写二维数组的过程)：  
（1）初始化：首先动态申请2n个单元；然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的父节点、左孩子、右孩子的下标都初始化为0；最后再循环n次，输入前n个单元中叶子结点的权值。  
（2）创建树：循环n-1次，通过n-1次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择父亲节点为0且权值最小的两个树根节点s1和s2；删除是指将节点s1和s2的父节点改为非0；合并就是将s1和s2的权值和作为一个新节点的权值一次存储到数组的第n+1之后的单元中，同时记录这个新节点左孩子下标为s1，右孩子的下标为s2。  

```c++
//select函数用来查找哈夫曼数组里面最小的两个数
void select(ht t,int n,int &s1,int &s2){
	//找最小的两个数，我之前的思路都是初始化后比较，但是如果第二个数在第一个数找到前就随意初始化会导致出现一定问题找不到，所以还是得一个个早，然后用不等于第一个数的思路来解决
    int i;
    for (i=1; i<=n; i++) {
        if (!t[i].parent) {
            break;
        }
    }
    s1 = i;
    for (int j=s1+1; j<=n; j++) {
        if (!t[j].parent && t[j].data < t[s1].data) {
            s1 = j;
        }
    }
    
    int k;
    for (k=1; k<=n; k++) {
        if (!t[k].parent && k!=s1) {
            break;
        }
    }
    s2 = k;
    for (int j=s2+1; j<=n; j++) {
        if (!t[j].parent && t[j].data < t[s2].data && j!=s1) {
            s2 = j;
        }
    }
}


void CreateHuffmanTree(HuffmanTree &HT,int n){
	//构造哈夫曼树HT
	if(n<=1) return;
	HT=new HTNode[2*n];
	for (int i = 1; i <= 2*n; ++i)
	{
		HT[i].parent = 0;
		HT[i].left = 0;
		HT[i].right = 0;
	}
	for (int i = 1; i <= n; ++i)
	{
		cin >> HT[i].weight;
	}

	//创建哈夫曼树
	for (int i = n+1; i < 2*n; ++i)
	{
		//通过n-1次的选择、删除、合并来创建哈夫曼树
		Select(HT,i-1,s1,s2);
		//在HT[k]（1<=k<=i-1）中选择两个其双亲域为0且权值最小的节点，并返回她们在HT中的序号s1和s2
		HT[s1].parent=i;HT[s2].parent=i;
		HT[i].left=s1;HT[i].right=s2;
		HT[i].weight=HT[s1].weight+HT[s2].weight;
	}
}

```
![HTree](/images/blog/HTree.png)  




















