---
layout: post
title: 非stl的基础算法练习
categories: Blog
description: 准备机试，尼玛居然不让用stl。
keywords: 算法, C语言
---
数据结构是重中之重，但是由于我在练习或比赛时一直对stl的频繁使用，似乎让我越来越对基础数据结构的代码能力越来越薄弱，由此重新开始练习基础。  
以《数据结构C（第二版）》严蔚敏、李冬梅老师书为训练基础。  

## 复杂度  

**时间复杂度**  
其实就是找循环和n有关的执行次数。
logn2的时间复杂度：   
```c++
for(int i=0;i<=n;i=i*2){
	x++;
}

//2^n<=n   f(n)=log2n 
```
**空间复杂度**  
其实就是找需要借助的大小n的复杂度  
例如逆序交换时只用一个数，与n的规模无关，则为O1。  
若是要用n大小数组，则为On。

## 程序设计要点  

1.不允许使用stl库，所以所有的数据结构都要自己编写所以基本用C来完成。  
2.对异常情况的处理，由于数据结构的书中会考虑许多不满足条件的情况以增加程序健壮性，所以基本上函数都是有int型返回值的，虽然不一定接受，可能这样更严谨吧。  

```c
//常用的返回值大概有三类
#define ok 1
#define error 0
#define overflow -2  
```


## 线性表   
线性表中主要有两种结构：顺序表和链表。  

### 顺序表   
顺序表指的是用一组地址连续的存储单元依次存储线性表的数据元素。  

**顺序表的存储结构**  
线性表可以根据需要增长或缩短，所以并不是简单的数组可以用来表示（在C语言中数组的给定需要提前给出长度，所以这里的感觉更像是stl中的vector）。  

```c++

struct sqlist{
	node *elem;		//当前空间的基地址
	int length;		//当前长度
};
```

**顺序表的初始化**  
完成两件事：  

1.为顺序表L分配一个预定大小的数组空间maxn（涉及内存分配的问题需要使用if来判断一下是否分配失败），用elem指向这段空间的基地址。   

2.将长度length设为0。   

```c++
int InitList(sqlist &L){
	L.elem = new node[Mansize];	//为顺序表分配存储空间
	if(!L.elem) return overflow;
	L.length = 0;
	return ok;
};
```

**顺序表的取值**  
完成两件事：  

1.判断指定的位置序号是否合理（1<=i<=L.length）;

2.若i合理则返回给一个&数;

```c++
int GetElem(sqlist &L,int i,node &e){
	if(i<1 || L.length)	return error;
	e = L.elem[i-1];
	return ok;
}
```

**顺序表的查找**  
返回查找到的序号  
完成两件事：  

1.依次比较，相等则返回序号   

2.找不到返回0  
```c++
int find(sqlist &L,node e){
	for(int i=0;i<L.length;i++)
		if(L.elem[i] == e)	return i+1;
	return 0;
}
```


**顺序表的插入**  
返回查找到的序号  
完成五件事：  
1.判断插入位置是否合法。  
2.判断存储空间是否已满。
3.将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置。   
4.放入元素在第i个位置。   
5.表长加1。  

```c++
int LisrInsert(sqlist &L,int i,node e){
	if((i<1)||(i>L.length+1))	return error;
	if(L.length == Mansize) return error;
	for (int j = L.length-1; j > i-1 ; j--)
	{
		/* code */
		L.elem[j+1]=L.elem[j];
	}
	L.elem[i-1]=e;
	L.length++;
	return ok;
}

```

**顺序表的删除**  
返回查找到的序号  
完成三件事：  
1.删除位置是否合法。  
2.i+1个往前移。
3.表长减1。   

```c++
int LisrDelete(sqlist &L,int i){
	if (i<1||i>L.length)	return ERROR;
	for (int j = i; j<= L.length-1; i++)
	{
		L.elem[j-1]=L.elem[j];
	}
	L.length--;
	return ok;
}

```


### 链表   
顺序表指的是用一组地址任意的（可连续，可不连续）存储单元依次存储线性表的数据元素。   

**链表的存储结构**  
线性表可以根据需要增长或缩短，所以并不是简单的数组可以用来表示（在C语言中数组的给定需要提前给出长度，所以这里的感觉更像是stl中的vector）。  

```c++
const int  
typedef struct Lnode{
	elem data;		//当前空间的基地址
	Lnode *next;		//当前长度
}Lnode,*LinkList;
```

**单链表的初始化**   
其实就是完成对头结点的初始化。  
```c++
void InitList(LinkList &l){
	l = new Lnode;
	l->next = NULL;
}

```

**单链表的取值**   
1.用指针p指向首元结点。计数器j=1.  
2.只要p不为NULL并且未到达i，p就指向下一个结点，并且计数器+1.
3.若p为NULL或j大于i这失败，若成功则改变参数e.  
```c++
int GetElem(LinkList &l,int i,elem &e){
	LinkList p;
	p = l->next;j=1;
	while(p && j<i){
		p=p->next;
		j++;
	}
	if(!p||j>i)	return error;
	e = p->data;
	return ok;
}

```

**单链表的查找**   
1.p指向首元结点.  
2.只要p不为NULL并且不等于e，p就指向下一个结点.
3.若p为NULL或j大于i这失败，若成功则改变参数e.  
```c
int GetElem(LinkList l,int i,elem e){
	LinkList p;
	p = l->next;
	while(p && p->data != e){
		p=p->next;
	}
	return p;
}

```


**单链表的插入**   
1.查找结点i-1并让p指向.  
2.生成一个新结点s.  
3.将数据域设为e.  
4.将新结点的指针域指向i.  
5.将p指向s.   
```c
int GetElem(LinkList &l,int i,elem &e){
	LinkList p,s;
	p = l->next;j=0;
	while(p && j<i-1){
		p=p->next;
		j++;
	}
	if(!p||j>i-1)	return error;
	s = new Lnode;
	s->node = e;
	s->next = p->next;
	p->next = s;
	return ok;
}

```


**单链表的删除**   
1.查找结点i-1并让p指向.  
2.临时保存待删结点i的地址在q中，以备释放.  
3.将结点p的指针域指向i的直接后继结点.  
4.将新结点的指针域指向i.  
```c
int GetElem(LinkList &l,int i){
	LinkList p,q;
	p = l->next;j=0;
	while(p && j<i-1){
		p=p->next;
		j++;
	}
	if(!p||j>i-1)	return error;
	q=p->next;
	p->next = q->next;
	delete q;
	return ok;
}

```

**单链表的创建**   
之前顺序表的创建是可以直接赋值的，但是链表的创建一般是靠两种方法。  
（1）前插法   
将结点插入头结点之后来创建链表的方法。  
1.首先初始化，得到一个只有头结点的空链表。  
2.循环n次：生成一个新结点p，输入数据域，将p插入到头结点之后。  
ps：需要注意的是，由于每次插入是在头部，所以需要逆序输入数据。  

```c
void creat_h(LinkList &l,int n){
	l = new Lnode;
	l->next = NULL;
	for (int i = 0; i < n; ++i)
	{
		p = new Lnode;
		cin >> p->data;
		p->next = l->next;
		l->next = p;
	}
}


```

(2)后插法  
为了使每次都插到最后需要一个尾指针。  
1.首先初始化，得到一个只有头结点的空链表。  
2.尾指针r初始化，指向头结点。  
3.循环n次：生成一个新结点p，输入数据域，指针域为空，将新结点p插入到尾结点r之后，指针r指向尾结点p。  

```c
void creat_r(LinkList &l,int n){
	l = new Lnode;
	l->next = NULL;
	LinkList r,p;
	r = l;
	for (int i = 0; i < n; ++i)
	{
		p = new Lnode;
		cin >> p->data;
		p->next = NULL;
		r->next = p;
		r=p;
	}
}

```

**链表的排序**  
总的来说还是冒泡排序，但是不能像顺序表那样直接选择这时候就需要再使用一个指针来代替。  

```c++

for(int i=0; i<l.length-1 ;i++){
	//i、j次数不变，但是需要用指针指到第一个数据
	LinkList p = l->next;
	for (int j = 0; j < l.length-i-1 ; j++)
	{
		if (p->data.price < p->next->data.price) {
                //并不需要复杂的换位置，直接交换结点数据内容即可
                book t = p->data;
                p->data = p->next->data;
                p->next->data = t;
            }
   		p=p->next;
   		//通过指向下一个来完成一次循环中的向后迁移
	}
}

```

**单链表的逆序**  
单链表的逆序最少需要用到四个指针，头指针l，h=l，t=h->next,s=t->next;   
完成指针指向的逆转，而不仅仅还是data的换位，逆转后把头指针移到末尾，头结点还在原来的位置，所以当输出时要提前判定一个node位。  



**查找两个单词链表共同后缀的起始结点**    
使用前插法得到倒序的单词序列，在遍历时需要提前一个节点进行检查，若不想等则现在指向的节点就是答案。   




**循环链表**    
最后一个结点的指针指向头结点，也就意味着头节点其实背两个指针共同指向（头指针、最后一个结点的指针），也可以发现没有结点的next为NULL。   
没有结点时头节点的next也指向本身。  

循环链表在操作上与单链表差不多，但是遍历时需要判定的是p！=L。  


**双向链表**    
为了克服链表的单项性，设计双向链表，存储结构如下，多了直接前驱：  
```c++

typedef struct Lnode
{
	elem data;
	Lnode *prior;	//直接前驱
	Lnode *next;
}*LinkList;

```


**顺序表和链表比较**    

***空间性能***  
1.存储空间的分配   
顺序表存储空间需要先分配，扩充受限制，而且易造成空间浪费。当线性表长度变化大、难以预估存储规模时，宜采用链表作为存储结构。  

2.存储密度的大小  
链表的结点处了设置数据与用来存储元素外还需设置指针域，所以顺序表密度等于1，链表密度小于1。当线性表长度变化不大、事先确定大小时，为了节约空间适合采用顺序表作为存储结构。  


***时间性能***  

1.存取效率     
顺序表由数组实现，是一种随机存储结构，取值效率高。链表是一种顺序存储结构，存取元素时只能依次遍历，效率比较低。若需多次存取操作，最好选择顺序表。    

2.插入删除效率     
对于链表，在确定插入删除位置后，插入删除操作无需移动数据，只需修改指针。而顺序表的插入删除操作平均需要移动一半的节点，时间复杂度较高。因此若线性表需要频繁的进行插入删除操作，宜采用链表作为存储结构。  


**线性表应用**    

***线性表的合并***  
算法步骤：
1.分别获取A表长m，B表长n。  
2.从B中第一个元素开始，循环n次执行以下操作：  
	将B中的第i个元素赋给e。  
	将A中查找元素e，如果不存在就插在A的最后。  

相当于以一个链表为基准去遍历另一个链表一次，时间复杂度为O(nm)。  


***有序表的合并***  
1.顺序表的合并    
	创建一个m+n的空表C   
	pc初始化，指向C的第一个元素   
	pa、pb也初始化，指向A、B的第一个元素  
	当指针pa、pb均为到达相应表尾时，则依次比较pa和pb的元素值，从A、B中选择较小的插入到C最后   
	如果pb/pa到达尾部，将LA/LB的剩余元素插入LC之后  

不是很常用，因为空间复杂度较高。要点就是要重新创建一个顺序表。  


2.链表的合并    
算法步骤：  
	指针pa、pb分别指向A、B的第一个结点。  
	C的节点取值为LA的头结点。  
	pc初始化，指向C的头结点。  
	当指针pa合pb均未到达相应表尾时，依次比较pa、pb说指向元素的值，选择较小的元素值插入到C的最后。   
	将非空表剩余段插入到pc所指的结点之后。  
	释放B的头结点。  

```c++

void MergeList(LinkList &a,LinkList &b,LinkList &c){
	LinkList pa = a->next,pb = b->next,pc;
	c = a;
	pc = c;
	while(pa && pb){
		if (pa->data <= pb->data)
		{
			pc->next = pa;
			pc=pa;
			pa=pa->next;
		}
		else{
			pc->next = pb;
			pc=pb;
			pb=pb->next;
		}
	}
	pc->next=pa?pa:pb;
	delete b;
}

```


**案例分析**    

***一元多项式***  
一元线性表可以用数组来表示，数组分量下标i即对应每项的系数，再运算时只要把两个数组对应的分量相加即可。  


***稀疏多项式***  
稀疏多项式的相加过程和归并两个有序表的过程及其类似，此过程常用链式存储结构更加灵活，(有点类似于稀疏图使用邻接表，而不是用邻接矩阵来描述一样)更适合表示一般的多项式，其中结点要进行一些变化。  
```c++

typedef struct PNode{
	float c;			//系数
	int e;				//指数
	Pnode *next;		
}*LinkList;

```

由此，在稀疏多项式相加时可以模拟链表归并的过程，因为稀疏多项式的项顺序是以系数递增或递减排列的，

***OJ练习***   

## 栈和队列   
### 顺序栈   
仅能在表尾进行插入和删除操作的线性表。栈可以进栈和出栈的一端称为栈顶，最里面的一端称为栈底。

**顺序栈的表示和实现**   
顺序栈是指利用顺序存储结构实现的栈，结构体的创建类似于顺序表，里面存在指针变量，代表地址。顺序栈定义如下：  
```c
#define MAXSIZE 100

typedef struct
{
	ElemType *base;	//栈底指针，初始化完成后，base始终指向栈底为止
	ElemType *top;  //栈顶指针，初值指向栈底
	int stacksize;	//栈最大容量
}SqStack;

```

**顺序栈的初始化**   
1.为顺序栈分配一个MAXSIZE的数组空间,并判断内存分配情况。  
2.使base指向这段空间的基地址，即栈底。  
3.top指向base，表示栈空。  
4.stacksize表示为最大容量MAXSIZE。   

```c

int InitStack(SqStack &s){
	s.base = new ElemType[MAXSIZE];
	if(!s.base) exit(error);
	s.top=s.base;
	s.stacksize = MAXSIZE;
	return ok;
}

```

**顺序栈的入栈**   

1.判断栈是否满  
2.将元素压入栈顶，栈顶指针加1   

ps：指针变量支持自增和自减操作，例如指针变量p+1代表p所指的int型变量的下一个int型变量地址，所以由此也可以完成类似数组遍历的操作。    

```c

int Push(SqStack &s,ElemType e){
	if(s.top-s.base == s.stacksize) return error;
	*s.top++ = e;	//自增运算符的优先级高于*，此表达式等价于*(s.top++)=e;
	return ok;
}
```

**顺序栈的出栈**   
1.判断栈是否为空   
2.栈顶指针减1，栈顶元素出栈   

```c

int Pop(SqStack &s,ElemType &e){
	if(s.top == s.base)	return erroe;
	e = *--s.top;
	return ok;
}

```

**取栈顶元素**   
需判断非空情况。  
```c
ElemType Top(SqStack s){
	if (s.top!=s.base)
	{
		return *(s.top-1);
	}
}
```

### 链栈   
链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示。  

**链栈的表示和实现**   
为了方便栈的插入和删除，一般以链表的头部作为栈顶，所以没必要附加一个头结点。  
```c

typedef struct StackNode{
	ElemType data;
	StackNode *next;
}*LinkStack;

```

**链栈初始化**   
其实就是让指针指空即可，可以不用写为一个函数。    
```c
void InitStack(LinkStack &s){
	s = null;
}
```

**链栈的入栈**   
    
```c

void Push(LinkStack &s,ElemType e){
	LinkStack p;
	p->data=e;
	p->next=s;
	s = n;
}

```

**取栈顶元素**   
    
```c

ElemType Top(LinkStack s){
	if (s!=NULL)
	{
		returns s->data;
	}
}

```














































