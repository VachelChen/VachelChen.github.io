---
layout: post
title: 非stl的基础算法练习
categories: Blog
description: 准备机试，尼玛居然不让用stl。
keywords: 算法, C语言
---
数据结构是重中之重，但是由于我在练习或比赛时一直对stl的频繁使用，似乎让我越来越对基础数据结构的代码能力越来越薄弱，由此重新开始练习基础。  
以《数据结构C（第二版）》严蔚敏、李冬梅老师书为训练基础。  

## 复杂度  

**时间复杂度**  
其实就是找循环和n有关的执行次数。
logn2的时间复杂度：   
```c++
for(int i=0;i<=n;i=i*2){
	x++;
}

//2^n<=n   f(n)=log2n 
```
**空间复杂度**  
其实就是找需要借助的大小n的复杂度  
例如逆序交换时只用一个数，与n的规模无关，则为O1。  
若是要用n大小数组，则为On。


## 线性表   
线性表中主要有两种结构：顺序表和链表。  

### 顺序表   
顺序表指的是用一组地址连续的存储单元依次存储线性表的数据元素。  

**顺序表的存储结构**  
线性表可以根据需要增长或缩短，所以并不是简单的数组可以用来表示（在C语言中数组的给定需要提前给出长度，所以这里的感觉更像是stl中的vector）。  

```c++
const int  
struct sqlist{
	node *elem;		//当前空间的基地址
	int length;		//当前长度
};
```

**顺序表的初始化**  
完成两件事：  

1.为顺序表L分配一个预定大小的数组空间maxn（涉及内存分配的问题需要使用if来判断一下是否分配失败），用elem指向这段空间的基地址。   

2.将长度length设为0。   

```c++
void InitList(sqlist &L){
	L.elem = new node[Mansize];
	if(!L.elem) exit(0);
	L.length = 0;
};
```

**顺序表的取值**  
完成两件事：  

1.判断指定的位置序号是否合理（1<=i<=L.length）;

2.若i合理则返回给一个&数;

```c++
void GetElem(sqlist &L,int i,node &e){
	if(i<1 || L.length)	return ERROR;
	e = L.elem[i-1];
}
```

**顺序表的查找**  
返回查找到的序号  
完成两件事：  

1.依次比较，相等则返回序号   

2.找不到返回0  
```c++
int find(sqlist &L,node e){
	for(int i=0;i<L.length;i++)
		if(L.elem[i] == e)	return i+1;
	return 0;
}
```


**顺序表的插入**  
返回查找到的序号  
完成五件事：  
1.判断插入位置是否合法。  
2.判断存储空间是否已满。
3.将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置。   
4.放入元素在第i个位置。   
5.表长加1。  

```c++
void LisrInsert(sqlist &L,int i,node e){
	if((i<1)||(i>L.length+1))	return error;
	if(L.length == Mansize) return eeror;
	for (int j = L.length-1; j > i-1 ; j--)
	{
		/* code */
		L.elem[j+1]=L.elem[j];
	}
	L.elem[i-1]=e;
	L.length++;
}

```

**顺序表的删除**  
返回查找到的序号  
完成三件事：  
1.删除位置是否合法。  
2.i+1个往前移。
3.表长减1。   

```c++
void LisrDelete(sqlist &L,int i){
	if (i<1||i>L.length)	return ERROR;
	for (int j = i; j<= L.length-1; i++)
	{
		L.elem[j-1]=L.elem[j];
	}
	L.length--;
}

```


### 链表   
顺序表指的是用一组地址任意的（可连续，可不连续）存储单元依次存储线性表的数据元素。   

**链表的存储结构**  
线性表可以根据需要增长或缩短，所以并不是简单的数组可以用来表示（在C语言中数组的给定需要提前给出长度，所以这里的感觉更像是stl中的vector）。  

```c++
const int  
struct node{
	node data;		//当前空间的基地址
	node *next;		//当前长度
};
```

**单链表的初始化**   







